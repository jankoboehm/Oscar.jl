abstract type ModuleFP_dec{T} <: ModuleFP{T} end
abstract type AbstractFreeMod_dec{T} <: AbstractFreeMod{T} end
abstract type AbstractSubQuo_dec{T} <: AbstractSubQuo{T} end

abstract type AbstractFreeModElem_dec{T} <: AbstractFreeModElem{T} end
abstract type AbstractSubQuoElem_dec{T} <: AbstractSubQuoElem{T} end

const CRing_dec = Union{MPolyRing_dec, MPolyQuo{<:Oscar.MPolyElem_dec}}
const CRingElem_dec = Union{MPolyElem_dec, MPolyQuoElem{<:Oscar.MPolyElem_dec}}
#TODO: "fix" to allow QuoElem s as well...
# this requires
#  re-typeing of FreeMod
#  typing of BiModArray
# ... and all the rest.
# parametrization has to be by elem_type(coeff_ring) and not, like currently, the bottom coeff ring
# Also: qring is a Singular native. So it needs to be added to the ring creation


# For all module types, including free modules we store canonical in and outgoing morphisms 
# which were generated by the function creating the module
# otherwise a free module consists out of a rank and a ring
# one can also provide names for the generators
mutable struct FreeMod_dec{T <: CRingElem_dec} <: AbstractFreeMod_dec{T}
  R::CRing_dec
  n::Int
  S::Vector{Symbol}
  d::Vector{GrpAbFinGenElem}

  ingoing_morphisms::Vector{<:ModuleMap}
  outgoing_morphisms::Vector{<:ModuleMap}

  AbstractAlgebra.@declare_other

  function FreeMod_dec{T}(n::Int,R::CRing_dec,S::Vector{Symbol},d::Vector{GrpAbFinGenElem}) where T <: CRingElem_dec
    r = new{elem_type(R)}()
    r.n = n
    r.R = R
    r.S = S
    r.d = d

    r.ingoing_morphisms = Vector{ModuleMap}()
    r.outgoing_morphisms = Vector{ModuleMap}()

    return r
  end
end

function FreeMod_dec(R::CRing_dec, n::Int, name::String = "e"; cached::Bool = false) 
  return FreeMod_dec{elem_type(R)}(n, R, [Symbol("$name[$i]") for i=1:n], [decoration(R)[0] for i=1:n])
end
free_module_dec(R::CRing_dec, n::Int, name::String = "e"; cached::Bool = false) = FreeMod_dec(R, n, name, cached = cached)

# if one des not provide names for the generators, the standard names e_i are used for the unit vectors
function FreeMod_dec(R::CRing_dec, n::Int, d::Vector{GrpAbFinGenElem}, name::String = "e"; cached::Bool = false) 
  return FreeMod_dec{elem_type(R)}(n, R, [Symbol("$name[$i]") for i=1:n],d)
end
free_module_dec(R::CRing_dec, n::Int, d::Vector{GrpAbFinGenElem}, name::String = "e"; cached::Bool = false) = FreeMod_dec(R, n, d, name, cached = cached)

#=XXX this cannot be as it is inherently ambigous
  - FreeMod(R, n)
  - direct sum of rings, ie. a ring
  - set of n-th powers of R
thus the "category" needs to be set explicitly

^(R::Ring_dec, n::Int) = FreeMod(R, n)
=#

function AbstractAlgebra.extra_name(F::FreeMod_dec)
  t = Hecke.get_special(F, :twist)
  if t !== nothing
    n = Hecke.get_special(t[1], :name)
    if n !== nothing
      return "$n($(t[2]))"
    end
  end
  if length(Set(F.d)) == 1
    n = Hecke.get_special(F.R, :name)
    if n !== nothing
      return "$n^$(ngens(F))($(-F.d[1]))"
    end
  end
  return nothing
end

function (F::FreeMod_dec)()
  return FreeModElem_dec(sparse_row(base_ring(F)), F)
end

function show(io::IO, F::FreeMod_dec)
  @show_name(io, F)
  @show_special(io, F)

  print(io, "Decorated free module of rank $(F.n) over ")
  print(IOContext(io, :compact =>true), F.R)

  i = 1
  while i < dim(F)
    d = F.d[i]
    j = 1
    while i+j <= dim(F) && d == F.d[i+j]
      j += 1
    end
    print(IOContext(io, :compact => true), F.R, "^$j")
    print(IOContext(io, :compact => true), "(", -d, ")")
    if i+j < dim(F)
      print(io, " + ")
    end
    i += j
  end
end

decoration(F::FreeMod_dec) = decoration(F.R)
decoration(R::MPolyRing_dec) = R.D

# two free modules are equal if the rank and the ring are
function Base.:(==)(F::FreeMod_dec, G::FreeMod_dec)
  # TODO it this enough or e.g. stored morphisms also be considered?
  return F.R == G.R && rank(F) == rank(G) && F.d == G.d && F.S == G.S
end

# elements of free modules are encoded in SRows
struct FreeModElem_dec{T} <: AbstractFreeModElem_dec{T}
  coords::SRow{T} # also usable via coeffs()
  parent::FreeMod_dec{T}
end

function FreeModElem(coords::SRow{T}, parent::FreeMod_dec{T}) where T <: CRingElem_dec
  return FreeModElem_dec{T}(coords, parent)
end

elem_type(::Type{FreeMod_dec{T}}) where {T} = FreeModElem_dec{T}
parent_type(::Type{FreeModElem_dec{T}}) where {T} = FreeMod_dec{T}
elem_type(::FreeMod_dec{T}) where {T} = FreeModElem_dec{T}


function degree(a::FreeModElem_dec)
  if iszero(a)
    error("zero has no degree")
  end
  first = true
  F = parent(a)
  W = base_ring(F)
  ww = W.D[0]
  local w
  for (p,v) = coords(a)
    w = degree(v)+F.d[p]
    if first
      ww = w
      first = false
    elseif isgraded(W)
      if ww != w
        error("elem not homogeneous")
      end
    else
      if W.lt(ww, w) 
        ww = w
      end
    end
  end
  return w
end

function homogeneous_components(a::FreeModElem_dec)
  res = Dict{GrpAbFinGenElem, FreeModElem_dec}()
  F = parent(a)
  for (p,v) = coords(a)
    c = homogeneous_components(v)
    for (pp, vv) = c
      w = pp + F.d[p]
      if haskey(res, w)
        res[w] += vv*gen(F, p)
      else
        res[w] = vv*gen(F, p)
      end
    end
  end
  return res
end

function homogeneous_component(a::FreeModElem_dec, g::GrpAbFinGenElem)
  F = parent(a)
  x = zero(F)
  for (p,v) = coords(a)
    x += homogeneous_component(v, g-F.d[p])*gen(F, p)
  end
  return x
end

function ishomogeneous(a::FreeModElem_dec)
  if iszero(a)
    return true
  end
  F = parent(a)
  first = true
  local d::GrpAbFinGenElem
  for (p,v) = coords(a)
    ishomogeneous(v) || return false
    if first
      d = F.d[p] + degree(v)
      first = false
    else
      F.d[p] + degree(v) == d || return false
    end
  end
  return true
end

# Weight vector or function?
# Should we already grade ModuleGens?
# Should it be possible to construct ungraded SubQuo with graded elements? (I.e. should the constructors
# accept AbstractFreeMod and AbstractFreeModElem instead of FreeMod and FreeModElem?)
# proceed with FreeModHom_dec?