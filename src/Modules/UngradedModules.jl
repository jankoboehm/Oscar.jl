export presentation

abstract type ModuleFP{T} end

const CRing = Union{MPolyRing, MPolyQuo{<:Oscar.MPolyElem}, MPolyRing_dec, MPolyQuo{<:Oscar.MPolyElem_dec}}
const CRingElem = Union{MPolyElem, MPolyQuoElem{<:Oscar.MPolyElem}, MPolyElem_dec, MPolyQuoElem{<:Oscar.MPolyElem_dec}}
#TODO: "fix" to allow QuoElem s as well...
# this requires
#  re-typeing of FreeModule
#  typing of BiModArray
# ... and all the rest.
# parametrization has to be by elem_type(coeff_ring) and not, like currently, the bottom coeff ring
# Also: qring is a Singular native. So it needs to be added to the ring creation

abstract type ModuleFPHom end
abstract type ModuleMap{T1, T2} <: Map{T1, T2, Hecke.HeckeMap, ModuleFPHom} end


# For all module types, including free modules we store canonical in and outgoing morphisms 
# which were generated by the function creating the module
# otherwise a free module consists out of a rank and a ring
# one can also provide names for the generators
mutable struct FreeMod{T} <: ModuleFP{T}
  R::CRing
  n::Int
  S::Array{Symbol, 1}

  ingoing_morphisms::Array{<:ModuleMap,1}
  outgoing_morphisms::Array{<:ModuleMap,1}

  AbstractAlgebra.@declare_other

  function FreeMod(n,b::CRing,c)
    r = new{elem_type(b)}()
    r.n = n
    r.R = b
    r.S = c

    r.ingoing_morphisms = Array{ModuleMap,1}()
    r.outgoing_morphisms = Array{ModuleMap,1}()

    return r
  end
end

# if one des not provide names for the generators, the standard names e_i are used for the unit vectors
function FreeMod(R::CRing, n::Int, name::String = "e"; cached::Bool = false) 
  return FreeMod(n, R, [Symbol("$name[$i]") for i=1:n])
end
free_module(R::CRing, n::Int, name::String = "e"; cached::Bool = false) = FreeMod(R, n, name, cached = cached)

#=XXX this cannot be as it is inherently ambigous
  - FreeModule(R, n)
  - direct sum of rings, ie. a ring
  - set of n-th powers of R
thus the "category" needs to be set explicitly

^(R::Ring_dec, n::Int) = FreeModule(R, n)
=#

function AbstractAlgebra.extra_name(F::FreeMod)
  return nothing
end

function (F::FreeMod)()
  return FreeModuleElem(sparse_row(base_ring(F)), F)
end

function show(io::IO, F::FreeMod)
  @show_name(io, F)
  @show_special(io, F)

  print(io, "Free module of rank $(F.n) over ")
  print(IOContext(io, :compact =>true), F.R)
#=
  i = 1
  while i < dim(F)
    d = F.d[i]
    j = 1
    while i+j <= dim(F) && d == F.d[i+j]
      j += 1
    end
    print(IOContext(io, :compact => true), F.R, "^$j")
    print(IOContext(io, :compact => true), "(", -d, ")")
    if i+j < dim(F)
      print(io, " + ")
    end
    i += j
  end
  =#
end

# Dimension, rank and number of generators
dim(F::FreeMod) = F.n
rank(F::FreeMod) = F.n
ngens(F::FreeMod) = dim(F)

# two free modules are equal if the rank and the ring are
function ==(F::FreeMod, G::FreeMod)
  # TODO it this enough or e.g. stored morphisms also be considered?
  return F.R == G.R && rank(F) == rank(G)
end

# the zero module is the module of rank zero
function iszero(F::FreeMod)
  return rank(F) == 0
end

# elements of free modules are encoded in SRows
struct FreeModuleElem{T}
  coords::SRow{T} # also usable via coeffs
  parent::FreeMod{T}
end

function Base.getproperty(v::FreeModuleElem, s::Symbol)
  if s == :coeffs
    return getfield(v, :coords)
  end
  return getfield(v, s)  
end

function getindex(v::FreeModuleElem, i::Int)
  if isempty(v.coords)
    return zero(base_ring(v.parent))
  end
  return v.coords[i]
end

elem_type(::Type{FreeMod{T}}) where {T} = FreeModuleElem{T}
parent_type(::Type{FreeModuleElem{T}}) where {T} = FreeMod{T}
elem_type(::FreeMod{T}) where {T} = FreeModuleElem{T}

function show(io::IO, e::FreeModuleElem)
  if length(e.coords) == 0
    print(io, 0)
    return
  end
  i = 1
  while i <= length(e.coords)
    print(io, "(", e.coords.values[i], ")*", e.parent.S[e.coords.pos[i]])
    if i < length(e.coords)
      print(io, " + ")
    end
    i += 1
  end
end

# a basis of the free module 
function basis(F::FreeMod)
  bas = elem_type(F)[]
  for i=1:dim(F)
    s = Hecke.sparse_row(F.R, [(i, F.R(1))])
    push!(bas, FreeModuleElem(s, F))
  end
  return bas
end
gens(F::FreeMod) = basis(F)

# the ith generator of the free module
function gen(F::FreeMod, i::Int)
  @assert 0 < i <= ngens(F)
  s = Hecke.sparse_row(F.R, [(i, F.R(1))])
  return FreeModuleElem(s, F)
end

function Base.getindex(F::FreeMod, i::Int)
  i == 0 && return zero(F)
  return gen(F, i)
end

# the base ring of the free module
base_ring(F::FreeMod) = F.R

#TODO: Parent - checks everywhere!!!

# the negative of a free module element
-(a::FreeModuleElem) = FreeModuleElem(-a.coords, a.parent)

# function to check whether a free module element is in a particular free module
function check_parent(a::FreeModuleElem, b::FreeModuleElem)
  if parent(a) !== parent(b)
    error("elements not compatible")
  end  
end

# Addition of free module elements
function +(a::FreeModuleElem, b::FreeModuleElem)
   check_parent(a, b)
   return FreeModuleElem(a.coords+b.coords, a.parent)
end

# Subtraction of free module elements
function -(a::FreeModuleElem, b::FreeModuleElem)
    check_parent(a,b)
    return FreeModuleElem(a.coords-b.coords, a.parent)
end

# Equality of free module elements
function ==(a::FreeModuleElem, b::FreeModuleElem) 
    check_parent(a,b)
    return a.coords == b.coords
end

# scalar multiplication with polynomials, integers
*(a::MPolyElem_dec, b::FreeModuleElem) = FreeModuleElem(a*b.coords, b.parent)
*(a::MPolyElem, b::FreeModuleElem) = FreeModuleElem(a*b.coords, b.parent)
*(a::Int, b::FreeModuleElem) = FreeModuleElem(a*b.coords, b.parent)
*(a::Integer, b::FreeModuleElem) = FreeModuleElem(b.parent.R(a)*b.coords, b.parent)
*(a::fmpq, b::FreeModuleElem) = FreeModuleElem(b.parent.R(a)*b.coords, b.parent)
# zero of a free module
zero(F::FreeMod) = FreeModuleElem(sparse_row(F.R, Tuple{Int, elem_type(F.R)}[]), F)
# parent of a free module element
parent(a::FreeModuleElem) = a.parent
# test whether a free module element is zero
iszero(a::FreeModuleElem) = Hecke.iszero(a.coords)

# data structure for a generating systems for submodules
# contains structures for the generators, the corresponding module on the Singular side, 
# the embedding free module, the embedding free module on the Singular side
# subquotients will be built from a tuple of submodules which again are given by 
# generating sets. In this way, the Singular stuff is hidden on the higher structures
# and all the conversion is taken care of here
# a module generating system is generated from an array of free module elements
# the fields are called O,S,F,SF rename?
#
# The same could be done rather on the level of vectors, that might be preferable if 
# performance is ok.
#
mutable struct ModuleGens{T}
  O::Array{FreeModuleElem{T}, 1}
  S::Singular.smodule
  F::FreeMod
  SF::Singular.FreeMod

  # ModuleGens from an Array of Oscar free module elements
  # Todo: Empty generating set
  function ModuleGens(O::Array{<:FreeModuleElem{T}, 1}) where {T}
    @assert length(O) > 0
    SF = singular_module(parent(O[1]))
    return ModuleGens(O, SF)
  end

  # ModuleGens from an Array of Oscar free module elements, specifying the Oscar free module
  # note that the array might be empty
  function ModuleGens(O::Array{<:FreeModuleElem, 1}, F::FreeMod{T}) where {T}
    SF = singular_module(F)
    return ModuleGens(O, F, SF)
  end

  # ModuleGens from an Array of Oscar free module elements, specifying the Singular free module
  # note that the array might be empty
  function ModuleGens(O::Array{<:FreeModuleElem{T}, 1}, SF::Singular.FreeMod) where {T}
    return ModuleGens(O, parent(O[1]), SF)
  end

  # ModuleGens from an Array of Oscar free module elements, specifying the free module 
  # and Singular free module, only useful indirectly
  function ModuleGens(O::Array{<:FreeModuleElem, 1}, F::FreeMod{T}, SF::Singular.FreeMod) where {T}
    r = new{T}()
    r.O = O
    r.SF = SF
    r.F = F
    return r
  end

  # ModuleGens from a Singular submodule
  function ModuleGens(F::FreeMod{S}, s::Singular.smodule) where {S} # FreeMod is neccessary due to type S
    r = new{S}()
    r.F = F
    if Singular.ngens(s) == 0
      r.SF = Singular.FreeModule(base_ring(s), 0)
    else
      r.SF = parent(s[1])
    end
    r.S = s
    return r
  end
end

# getproperty is used to fill in fields with duplicate data
function Base.getproperty(M::ModuleGens, s::Symbol)
  if s == :S
    singular_assure(M)
    return getfield(M, s)
  elseif s == :O
    oscar_assure(M)
    return getfield(M, s)
  else
    return getfield(M,s)
  end
end

# Test for zero module
function iszero(M::ModuleGens)
  return iszero(M.S)
end

# remove output saying defined on the Singular side?
function show(io::IO, F::ModuleGens)
  println(io, "Array of length ", length(F))
  for i=1:length(F)
    if isassigned(F.O, i)
      println(io, i, " -> ", F.O[i])
    end
  end
  if isdefined(F, :S)
    println(io, "defined on the Singular side")
  end
end

# number of elements of the module generating set
length(F::ModuleGens) = length(F.O)
# number of elements of the module generating set
ngens(F::ModuleGens) = length(F.O)

# i-th entry of module generating set on Oscar side
# Todo: clean up, convert or assure
function getindex(F::ModuleGens, ::Val{:O}, i::Int)
  if !isassigned(F.O, i)
    F.O[i] = convert(F.F, F.S[i])
  end
  return F.O[i]
end

# i-th entry of module generating set on Singular side
# Todo: clean up, convert or assure
function getindex(F::ModuleGens, ::Val{:S}, i::Int)
  if !isdefined(F, :S)
    F.S = Singular.smodule{elem_type(base_ring(F.SF))}(base_ring(F.SF), [convert(F.SF,x) for x = F.O]...)
  end
  return F.S[i]
end

# fill in the OSCAR side, given the Singular side
function oscar_assure(F::ModuleGens)
  if !isdefined(F, :O)
    F.O = [convert(F.F, F.S[i]) for i=1:Singular.ngens(F.S)]
  end
end

# fill in the Singular side, given the OSCAR side
function singular_assure(F::ModuleGens)
  if !isdefined(F, :S)
    if length(F) == 0
      singular_ring = base_ring(F.SF)
      F.S = Singular.smodule{elem_type(base_ring(F.SF))}(singular_ring, Singular.vector(singular_ring, singular_ring(0)))
      return 
    end
    F.S = Singular.smodule{elem_type(base_ring(F.SF))}(base_ring(F.SF), [convert(F.SF,x) for x = F.O]...)
    return
  end
  #F[Val(:S), 1]
end

# i-th entry of module generating set (taken from Oscar side)
getindex(F::ModuleGens, i::Int) = getindex(F, Val(:O), i)

# create a Singular free module from an OSCAR free module
function singular_module(F::FreeMod)
  Sx = singular_ring(base_ring(F))
  return Singular.FreeModule(Sx, dim(F))
end

# convert an OSCAR free module element to the Singular side
function convert(SF::Singular.FreeMod, m::FreeModuleElem)
  g = Singular.gens(SF)
  e = SF()
  Sx = base_ring(SF)
  for (p,v) = m.coords
    e += Sx(v)*g[p]
  end
  return e
end

# convert a Singular vector to a free module element on the OSCAR side
function convert(F::FreeMod, s::Singular.svector)
  pv = Tuple{Int, elem_type(base_ring(F))}[]
  pos = Int[]
  values = []
  Rx = base_ring(F)
  R = base_ring(Rx)
  for (i, e, c) = s
    f = Base.findfirst(x->x==i, pos)
    if f === nothing
      push!(values, MPolyBuildCtx(base_ring(F)))
      f = length(values)
      push!(pos, i)
    end
    push_term!(values[f], R(c), e)
  end
  pv = Tuple{Int, elem_type(Rx)}[(pos[i], base_ring(F)(finish(values[i]))) for i=1:length(pos)]
  return FreeModuleElem(sparse_row(base_ring(F), pv), F)
end

# data structure for homomorphisms of free modules
mutable struct FreeModuleHom{T1, T2} <: ModuleMap{T1, T2} 
  matrix::MatElem
  header::MapHeader
  inverse_isomorphism::ModuleMap
  Hecke.@declare_other

  # generate homomorphism of free modules from F to G where the Array a contains the images of
  # the generators of F
  function FreeModuleHom(F::FreeMod{T}, G::S, a::Array{<:Any, 1}) where {T, S}
    @assert all(x->parent(x) == G, a)
    @assert length(a) == ngens(F)
    r = new{typeof(F), typeof(G)}()
    function im_func(x::FreeModuleElem)
      b = zero(G)
      for (i,v) = x.coords
        b += v*a[i]
      end
      return b
    end
    function pr_func(x::FreeModuleElem)
      @assert parent(x) == G
      c = coordinates(x, sub(G, a)) 
      return FreeModuleElem(c, F)
    end
    function pr_func(x)
      @assert parent(x) == G
      c = coordinates(x.repres, sub(G, a))
      if isempty(c)
        c = sparse_row(F.R)
      end
      return FreeModuleElem(c, F)
    end
    r.header = MapHeader{typeof(F), typeof(G)}(F, G, im_func, pr_func)

    return r
  end

  function FreeModuleHom(F::FreeMod{T}, G::S, mat::MatElem{T}) where {T,S}
    @assert nrows(mat) == ngens(F)
    @assert ncols(mat) == ngens(G)
    if typeof(G) <: FreeMod
      hom = FreeModuleHom(F, G, [FreeModuleElem(sparse_row(mat[i,:]), G) for i=1:ngens(F)])
    else
      hom = FreeModuleHom(F, G, [SubQuoElem(sparse_row(mat[i,:]), G) for i=1:ngens(F)])
    end
    hom.matrix = mat
    return hom
  end
end

function Base.getproperty(f::FreeModuleHom, s::Symbol)
  if s == :matrix
    if !isdefined(f, s)
      D = domain(f)
      C = codomain(f)
      R = base_ring(D)
      matrix = zero_matrix(R, D.n, ngens(C))
      for i=1:D.n
        image_of_gen = f(D[i])
        for j=1:ngens(C)
          matrix[i,j] = image_of_gen[j]
        end
      end
      setfield!(f, s, matrix)
    end
  end
  return getfield(f, s)
end

(h::FreeModuleHom)(a::FreeModuleElem) = image(h, a)

hom(F::FreeMod{T}, G, a) where {T} = FreeModuleHom(F, G, a)

function identity_map(M::ModuleFP)
  return hom(M, M, gens(M))
end

mutable struct SubModuleOfFreeModule{T} <: ModuleFP{T}
  F::FreeMod{T}
  gens::ModuleGens
  std_basis::ModuleGens
  matrix::MatElem

  function SubModuleOfFreeModule(F::FreeMod{R}, gens::Array{<:FreeModuleElem, 1}) where {R}
    @assert all(x -> parent(x) == F, gens)
    r = new{R}()
    r.F = F
    r.gens = ModuleGens(gens, F)
    return r
  end

  function SubModuleOfFreeModule(F::FreeMod{R}, singular_module::Singular.smodule) where {R}
    r = new{R}()
    r.F = F
    r.gens = ModuleGens(F, singular_module)
    if singular_module.isGB
      r.std_basis = r.gens
    end
    return r
  end
  
  function SubModuleOfFreeModule(F::FreeMod{R}, gens::ModuleGens) where {R}
    r = new{R}()
    r.F = F
    r.gens = gens
    if gens.S.isGB
      r.std_basis = r.gens
    end
    return r
  end

  function SubModuleOfFreeModule(A::MatElem{L}) where {L}
    r = new{L}()
    R = base_ring(A)
    F = FreeMod(R, ncols(A))
    r.F = F
    O = [FreeModuleElem(sparse_row(A[i,:]), F) for i in 1:nrows(A)]
    r.gens = ModuleGens(O, F)
    r.matrix = A
    return r
  end
end

function Base.getproperty(submod::SubModuleOfFreeModule, s::Symbol)
  if s == :std_basis
    if !isdefined(submod, s)
        setfield!(submod, s, groebner_basis(submod.gens))
    end
    return getfield(submod, s)
    
  elseif s == :matrix
    if !isdefined(submod, s)
      R = base_ring(submod)
      matrix = zero_matrix(R, length(submod.gens), rank(submod.F))
      for i = 1:nrows(matrix), j = 1:ncols(matrix)
        #matrix[i,j] = submod.gens[i].coords[j]
        matrix[i,j] = submod.gens[i][j] 
      end

      setfield!(submod, s, matrix)
    end
    return getfield(submod, s)
  else
    return getfield(submod, s)
  end
end

function Base.getindex(M::SubModuleOfFreeModule, i::Int)
  return M.gens.O[i]
end

function iszero(M::SubModuleOfFreeModule)
  return iszero(M.gens)
end

function base_ring(M::SubModuleOfFreeModule)
  return base_ring(M.F)
end

function isgeneratd_by_unit_vectors(M::SubModuleOfFreeModule)
  m,n = size(M.matrix)
  if m != n 
    return false
  end
  return M.matrix == identity_matrix(base_ring(M),n)
end

function show(io::IO, M::SubModuleOfFreeModule)
  if ngens(M) == 1
    println(io, "Submodule with ", ngens(M), " generator")
  else
    println(io, "Submodule with ", ngens(M), " generators")
  end
  for i=1:ngens(M)
    if isassigned(M.gens.O, i)
      println(io, i, " -> ", M[i])
    end
  end
  if isdefined(M.gens, :S)
    println(io, "defined on the Singular side")
  end
end

function length(M::SubModuleOfFreeModule)
  #TODO replace all calls by ngens
  return length(M.gens)
end

function ngens(M::SubModuleOfFreeModule)
  return ngens(M.gens)
end

function gens(M::SubModuleOfFreeModule)
  return M.gens.O
end

function gen(M::SubModuleOfFreeModule, i::Int)
  return M.gens[Val(:O), i]
end

function sum(M::SubModuleOfFreeModule, N::SubModuleOfFreeModule)
  @assert M.F == N.F
  return SubModuleOfFreeModule(M.F, vcat(collect(M.gens), collect(N.gens)))
end

function ==(M::SubModuleOfFreeModule, N::SubModuleOfFreeModule)
  @assert M.F == N.F
  M_mod_N = _reduce(M.std_basis.S, N.std_basis.S)
  N_mod_M = _reduce(N.std_basis.S, M.std_basis.S)
  return iszero(M_mod_N) && iszero(N_mod_M)
end

#+(M::SubModuleOfFreeModule, N::SubModuleOfFreeModule) = sum(M, N)

mutable struct SubQuo{T} <: ModuleFP{T}
  #meant to represent sub+ quo mod quo - as lazy as possible
  F::FreeMod{T}
  sub::SubModuleOfFreeModule
  quo::SubModuleOfFreeModule
  sum::SubModuleOfFreeModule

  ingoing_morphisms::Array{<:ModuleMap,1}
  outgoing_morphisms::Array{<:ModuleMap,1} # TODO is it possible to make ModuleMap to SubQuoHom?

  AbstractAlgebra.@declare_other

  function SubQuo(sub::SubModuleOfFreeModule{R}) where {R}
    r = new{R}()
    r.F = sub.F
    r.sub = sub
    r.sum = r.sub

    r.ingoing_morphisms = Array{ModuleMap,1}()
    r.outgoing_morphisms = Array{ModuleMap,1}()

    return r
  end
  function SubQuo(sub::SubModuleOfFreeModule{R}, quo::SubModuleOfFreeModule{R}) where {R}
    @assert sub.F == quo.F
    r = new{R}()
    r.F = sub.F
    r.sub = sub
    r.quo = quo
    r.sum = sum(r.sub, r.quo)

    r.ingoing_morphisms = Array{ModuleMap,1}()
    r.outgoing_morphisms = Array{ModuleMap,1}()

    return r
  end
  function SubQuo(F::FreeMod{R}, O::Array{<:FreeModuleElem, 1}) where {R}
    r = new{R}()
    r.F = F
    #r.sub = ModuleGens(O, F, singular_module(F))
    r.sub = SubModuleOfFreeModule(F, O)
    r.sum = r.sub

    r.ingoing_morphisms = Array{ModuleMap,1}()
    r.outgoing_morphisms = Array{ModuleMap,1}()

    return r
  end
  function SubQuo(S::SubQuo{L}, O::Array{<:FreeModuleElem, 1}) where {L} #TODO to be replaced by quo
    r = new{L}()
    r.F = S.F
    r.sub = S.sub
    #r.quo = ModuleGens(O, S.F, S.sub.SF)
    r.quo = SubModuleOfFreeModule(S.F, O)
    #r.sum = ModuleGens(vcat(collect(r.sub), collect(r.quo)), S.F, S.sub.SF)
    r.sum = sum(r.sub, r.quo)

    r.ingoing_morphisms = Array{ModuleMap,1}()
    r.outgoing_morphisms = Array{ModuleMap,1}()

    return r
  end
  #=function SubQuo(S::SubQuo, O::Array{<:SubQuoElem, 1})
    @assert all(x->x.parent === S, O)
    r = SubQuo(S.F, [x.repres for x in O])
    r.quo = S.quo
    r.sum = sum(r.sub, r.quo)
    return r
  end=#
  function SubQuo(F::FreeMod{R}, s::Singular.smodule) where {R}
    r = new{R}()
    r.F = F
    #r.sub = ModuleGens(F, s)
    r.sub = SubModuleOfFreeModule(F, s)
    r.sum = r.sub

    r.ingoing_morphisms = Array{ModuleMap,1}()
    r.outgoing_morphisms = Array{ModuleMap,1}()

    return r
  end
  function SubQuo(F::FreeMod{R}, s::Singular.smodule, t::Singular.smodule) where {R}
    r = new{R}()
    r.F = F
    #r.sub = ModuleGens(F, s)
    r.sub = SubModuleOfFreeModule(F, s)
    #r.quo = ModuleGens(F, t)
    r.quo = SubModuleOfFreeModule(F, t)
    #r.sum = ModuleGens(vcat(collect(r.sub), collect(r.quo)))
    r.sum = sum(r.sub, r.quo)

    r.ingoing_morphisms = Array{ModuleMap,1}()
    r.outgoing_morphisms = Array{ModuleMap,1}()

    return r
  end

  function SubQuo(A::MatElem{R}, B::MatElem{R}) where {R}
    @assert ncols(A) == ncols(B)
    return SubQuo(SubModuleOfFreeModule(A), SubModuleOfFreeModule(B))
  end
end

function show(io::IO, SQ::SubQuo)
  @show_name(io, SQ)
  @show_special(io, SQ)

  if isdefined(SQ, :quo)
    println(io, "Subquotient of ", SQ.sub, "by ", SQ.quo)
  else
    #println(io, "Subquotient by ", SQ.sub)
    println(io, SQ.sub)
    println("represented as subquotient with no relations.")
  end
end

function show_subquo(SQ::SubQuo)
  #@show_name(io, SQ)
  #@show_special(io, SQ)

  if isdefined(SQ, :quo)
    if isgeneratd_by_unit_vectors(SQ.sub)
      println("Cokernel of ", SQ.quo.matrix)
    else
      println("Subquotient with of image of")
      display(SQ.sub.matrix)
      println("by image of")
      display(SQ.quo.matrix)
      #println("Subquotient with of image of ", SQ.sub.matrix, " by image of ", SQ.quo.matrix)
    end
  else
    println("Image of ", SQ.sub.matrix)
  end
end

function cokernel(f::FreeModuleHom)
  @assert typeof(codomain(f)) <: FreeMod
  return quo(codomain(f), image(f)[1])
end

function cokernel(A::MatElem)
  R = base_ring(A)
  domain_F = FreeMod(R, nrows(A))
  codomain_F = FreeMod(R, ncols(A))
  
  f = FreeModuleHom(domain_F, codomain_F, A)
  return cokernel(f)
end

function ==(M::SubQuo{T}, N::SubQuo{T}) where {T}
  if !isdefined(M, :quo) 
    if !isdefined(N, :quo)
      return M.sub == N.sub
    else
      return iszero(N.quo) && M.sub == N.sub
    end
  else
    if !isdefined(N, :quo)
      return iszero(M.quo) && M.sub == N.sub
    else
      return M.quo == N.quo && M.sum == N.sum
    end
  end
end

function sum(M::SubQuo{T},N::SubQuo{T}) where T
  #TODO use SubModuleOfFreeModule instead of matrices
  n_rel = N.quo.matrix
  m_rel = M.quo.matrix

  if (m_rel == n_rel) || Set([m_rel[i,:] for i=1:size(m_rel)[1]])==Set([n_rel[j,:] for j=1:size(n_rel)[1]]) || M.quo == N.quo
    SQ = SubQuo(vcat(M.sub.matrix, N.sub.matrix), m_rel)

    gm1,gm2 = size(M.sub.matrix)
    gn1,gn2 = size(N.sub.matrix)
    R = base_ring(M)

    # injection maps:
    M_mat = hcat(identity_matrix(R,gm1), zero_matrix(R,gm1,gn1))
    iM = SubQuoHom(M,SQ,M_mat)

    N_mat = hcat(zero_matrix(R,gn1,gm1), identity_matrix(R,gn1))
    iN = SubQuoHom(N,SQ,N_mat)

    register_morphism!(iM)
    register_morphism!(iN)

    return SQ, iM, iN
  end
  throw(ArgumentError("img(M.relations) != img(N.relations)"))
end

function Base.:intersect(M::SubQuo{T}, N::SubQuo{T}) where T
  #TODO allow task as argument?
  n_rel = N.quo.matrix
  m_rel = M.quo.matrix

  if (m_rel == n_rel) || Set([m_rel[i,:] for i=1:size(m_rel)[1]])==Set([n_rel[j,:] for j=1:size(n_rel)[1]]) || M.quo == N.quo
    n = size(N.sub.matrix)
    m = size(M.sub.matrix)
    if n[2]!=m[2]
      throw(DimensionMismatch("Matrices have different number of columns"))
    end

    global_module_matrix = vcat(M.sub.matrix, N.sub.matrix, M.quo.matrix)

    CD = matrix_kernel(global_module_matrix)

    C = CD[:,1:m[1]]
    D = CD[:,(m[1]+1):(m[1]+n[1])]
    new_gen = C*M.sub.matrix
    SQ = SubQuo(new_gen, m_rel)

    M_hom = SubQuoHom(SQ,M,C)
    N_hom = SubQuoHom(SQ,N,D)
    register_morphism!(M_hom)
    register_morphism!(N_hom)

    return SQ,M_hom,N_hom
  end
  throw(ArgumentError("img(M.relations) != img(N.relations)"))
end

@doc Markdown.doc"""
  A subquotient is (internally) given wia two submodules A and B of the same 
  FreeModule F. It represents $(A+B)/B$, so elements are given as elements
  in $A+B$
"""
struct SubQuoElem{T} # this needs to be redone TODO
  coeffs::SRow{T}
  repres::FreeModuleElem{T}
  parent::SubQuo

  function SubQuoElem(v::SRow{R}, SQ::SubQuo) where {R}
    @assert length(v) <= ngens(SQ.sub)
    if isempty(v)
      r = new{R}(v, zero(SQ.F), SQ)
      return r
    end
    r = new{R}(v, Base.sum([v[i]*SQ.sub[i] for i=1:ngens(SQ.sub)]), SQ)
    #r.coeffs = v
    #r.parent = SQ
    #r.repres = sum([v[i]*SQ.F[i] for i=1:ngens(SQ.F)]...)
    return r
  end

  function SubQuoElem(a::FreeModuleElem{R}, SQ::SubQuo) where {R}
    @assert a.parent === SQ.F
    r = new{R}(coordinates(a,SQ), a, SQ)
    #r.parent = SQ
    #r.repres = a
    #r.v = coordinates(a, SQ)
    return r
  end
end

elem_type(::SubQuo{T}) where {T} = SubQuoElem{T}
parent_type(::SubQuoElem{T}) where {T} = SubQuo{T}
elem_type(::Type{SubQuo{T}}) where {T} = SubQuoElem{T}
parent_type(::Type{SubQuoElem{T}}) where {T} = SubQuo{T}

function getindex(v::SubQuoElem, i::Int)
  if isempty(v.coeffs)
    return zero(base_ring(v.parent))
  end
  return v.coeffs[i]
end

function groebner_basis(F::ModuleGens)
  singular_assure(F)
  if F.S.isGB
    return F
  end
  return ModuleGens(F.F, Singular.std(F.S))
end

function show(io::IO, b::SubQuoElem)
  print(io, b.repres)
end

parent(b::SubQuoElem) = b.parent

function (R::SubQuo)(a::FreeModuleElem; check::Bool = true)
  if check
    b = convert(R.sum.gens.SF, a)
    c = _reduce(b, R.sum.std_basis.S)
    iszero(c) || error("not in the module")
  end
  return SubQuoElem(a, R)
end

function (R::SubQuo)(a::SRow)
  return SubQuoElem(a, R)
end

function (R::SubQuo)(a::SubQuoElem)
  if parent(a) == R
    return a
  end
  error("illegal coercion")
end

function index_of_gen(v::SubQuoElem)
  @assert length(v.coeffs.pos) == 1
  @assert isone(v.coeffs.values[1])
  return v.coeffs.pos[1]
end

+(a::SubQuoElem, b::SubQuoElem) = SubQuoElem(a.coeffs+b.coeffs, a.parent)
-(a::SubQuoElem, b::SubQuoElem) = SubQuoElem(a.coeffs-b.coeffs, a.parent)
-(a::SubQuoElem) = SubQuoElem(-a.coeffs, a.parent)
*(a::MPolyElem_dec, b::SubQuoElem) = SubQuoElem(a*b.coeffs, b.parent)
*(a::MPolyElem, b::SubQuoElem) = SubQuoElem(a*b.coeffs, b.parent)
*(a::Int, b::SubQuoElem) = SubQuoElem(a*b.coeffs, b.parent)
*(a::Integer, b::SubQuoElem) = SubQuoElem(a*b.coeffs, b.parent)
*(a::fmpq, b::SubQuoElem) = SubQuoElem(a*b.coeffs, b.parent)
==(a::SubQuoElem, b::SubQuoElem) = iszero(a-b)

function sub(F::FreeMod, O::Array{<:FreeModuleElem, 1}, task::Symbol = :none)
  s = SubQuo(F, O)
  if task == :none || task == :module
    return s
  else
    emb = hom(s, F, O)
    task == :store && register_morphism!(emb)
    task == :morphism && return emb
    return s, emb
  end
end

function sub(F::FreeMod, O::Array{<:SubQuoElem, 1}, task::Symbol = :none)
  s = SubQuo(F, [x.repres for x = O])
  return sub(F, s, task)
  #=if task == :none
    return s
  else
    emb = hom(s, F, [x.repres for x = O])
  end=#
end

function sub(F::FreeMod, s::SubQuo, task::Symbol = :none)
  @assert !isdefined(s, :quo)
  @assert s.F == F
  if task == :none || task == :module
    return s
  else
    emb = hom(s, F, [FreeModuleElem(x.repres.coords, F) for x in gens(s)])
    task == :store && register_morphism!(emb)
    task == :morphism && return emb 
    return s, emb
  end
end

function sub(S::SubQuo, O::Array{<:SubQuoElem, 1}, task::Symbol = :none, check_only_relations = false)
  if !check_only_relations
    @assert all(x -> x.parent === S, O)
  else
    if length(O) > 0
      @assert O[1].parent.quo == S.quo
    end
  end
  t = SubQuo(S.F, [x.repres for x in O])
  if isdefined(S, :quo)
    t.quo = S.quo
    t.sum = sum(t.sub, t.quo)
  end
  if task == :none || task == :module
    return t
  else
    emb = hom(t, S, O)
    task == :store && register_morphism!(emb)
    task == :morphism && return emb 
    return t, emb
  end

  #=t = sub(S.F, O, task)
  if task != :none
    t,emb = t
  end
  if isdefined(S, :quo)
    s = quo(t, collect(S.quo.gens))
    if task == :none
      return s
    else
      emb2 = hom(s, S, [SubQuoElem(x.repres, S) for x in gens(s)])
    end
  else
    return t
  end=#
end

function quo(F::FreeMod, O::Array{<:FreeModuleElem, 1}, task::Symbol = :none)
  S = SubQuo(F, basis(F))
  Q = SubQuo(S, O)

  return return_quo_wrt_task(F, Q, task)
end

function quo(F::FreeMod, O::Array{<:SubQuoElem, 1}, task::Symbol = :none)
  S = SubQuo(F, basis(F))
  Q = SubQuo(S, [x.repres for x = O])
  
  return return_quo_wrt_task(F, Q, task)
end

function quo(F::SubQuo, O::Array{<:FreeModuleElem, 1}, task::Symbol = :none)
  if length(O) > 0
    @assert parent(O[1]) == F.F
  end
  if isdefined(F, :quo)
    #F.sub[Val(:S), 1]
    #[F.quo.gens[Val(:O), i] for i = 1:length(F.quo.gens.O)] 
    oscar_assure(F.quo.gens)
    s = Singular.smodule{elem_type(base_ring(F.quo.gens.SF))}(base_ring(F.quo.gens.SF), [convert(F.quo.gens.SF, x) for x = [O; F.quo.gens.O]]...)
    Q = SubQuo(F.F, F.sub.gens.S, s)
    return return_quo_wrt_task(F, Q, task)
  end
  Q = SubQuo(F, O)
  return return_quo_wrt_task(F, Q, task)
end

function quo(S::SubQuo, O::Array{<:SubQuoElem, 1}, task::Symbol = :none)
  return quo(S, [x.repres for x = O], task)
end

function quo(S::SubQuo, T::SubQuo, task::Symbol = :none)
#  @assert !isdefined(T, :quo)
  # TODO @assert S.quo == T.quo or too expensive?
  Q = SubQuo(S, T.sum.gens.O)
  return return_quo_wrt_task(S, Q, task)
end

function quo(F::FreeMod, T::SubQuo, task::Symbol = :none)
  @assert !isdefined(T, :quo)
  return quo(F, gens(T), task)
end

function return_quo_wrt_task(M::ModuleFP, Q::ModuleFP, task)
  if task == :none || task == :module
    return Q
  else
    pro = hom(M, Q, gens(Q))
    task == :store && register_morphism!(pro)
    task == :morphism && return pro
    return Q, pro
  end
end

function syzygy_module(F::ModuleGens; sub = 0)
  F[Val(:S), 1] #to force the existence of F.S
  s = Singular.syz(F.S) # TODO syz is sometimes too slow, example [8*x^2*y^2*z^2 + 13*x*y*z^2 12*x^2 + 7*y^2*z; 13*x*y^2 + 12*y*z^2 4*x^2*y^2*z + 8*x*y*z; 9*x*y^2 + 4*z 12*x^2*y*z^2 + 9*x*y^2*z]
  if sub !== 0
    G = sub
  else
    G = FreeMod(base_ring(F.F), length(F.O))
  end
  return SubQuo(G, s)
end

function gens(F::SubQuo)
  return [gen(F,i) for i=1:ngens(F)]
end

function gen(F::SubQuo, i::Int)
  R = base_ring(F)
  v = sparse_row(R)
  v.pos = [i]
  v.values = [R(1)]
  return SubQuoElem(v, F)
end

ngens(F::SubQuo) = ngens(F.sub)
base_ring(SQ::SubQuo) = base_ring(SQ.F)

zero(SQ::SubQuo) = SubQuoElem(zero(SQ.F), SQ)

function Base.iszero(F::SubQuo)
  return all(iszero, gens(F))
end

function Base.getindex(F::SubQuo, i::Int)
  i == 0 && return zero(F)
  return gen(F, i)
end

function Base.iterate(F::ModuleGens, i::Int = 1)
  if i>length(F)
    return nothing
  else
    return F[i], i+1
  end
end
Base.eltype(::ModuleGens{T}) where {T} = FreeModuleElem{T} 

#??? A scalar product....
function *(a::FreeModuleElem, b::Array{FreeModuleElem, 1})
  @assert dim(parent(a)) == length(b)
  s = zero(parent(a))
  for (p,v) = a.coords
    s += v*b[p]
  end
  return s
end

function presentation(SQ::SubQuo)
  #A+B/B is generated by A and B
  #the relations are A meet B? written wrt to A
  s = syzygy_module(SQ.sum.gens)
  #TODO: wait for Hans to release Modulo(A, B) that does exactly this
  c = collect(s.sub.gens)
  R = base_ring(SQ)
  F = FreeMod(R, ngens(SQ.sub))
  q = elem_type(F)[]

  for x = c
    b = sparse_row(R)
    e = zero(SQ.F)
    for (i,v) = x.coords
      if i>ngens(SQ)
        break
      end
      e += v*gen(SQ, i).repres
      push!(b.pos, i)
      push!(b.values, v)
    end
    #=if length(b) == 0 #TODO why was this here
      continue
    end=#
    push!(q, FreeModuleElem(b, F))
  end
  #want R^a -> R^b -> SQ -> 0
  #TODO sort decoration and fix maps, same decoration should be bundled (to match pretty printing)
  G = FreeMod(R, ngens(s.sub))
  h_G_F = hom(G, F, q)
  h_F_SQ = hom(F, SQ, gens(SQ)) # DO NOT CHANGE THIS LINE, see present and preimage

  Z = FreeMod(F.R, 0)
  Hecke.set_special(Z, :name => "Zero")
  h_SQ_Z = hom(SQ, Z, [zero(Z) for i=1:ngens(SQ)])
  return Hecke.ChainComplex(Oscar.ModuleFP, Oscar.ModuleMap[h_G_F, h_F_SQ, h_SQ_Z], check = false)
end

function presentation(F::FreeMod)
  Z = FreeMod(F.R, 0)
  Hecke.set_special(Z, :name => "Zero")
  return Hecke.ChainComplex(ModuleFP, ModuleMap[hom(Z, F, FreeModuleElem[]), hom(F, F, gens(F)), hom(F, Z, [zero(Z) for i=1:ngens(F)])], check = false)
end

function present(SQ::SubQuo, task::Symbol = :none)
  chainComplex = presentation(SQ)
  R_b = obj(chainComplex, 1)
  f = map(chainComplex, 1)
  g = map(chainComplex, 2)
  presentation_module = quo(R_b, image(f)[1])

  if task == :none
    return presentation_module
  end
  
  # The isomorphism is just the identity matrix
  isomorphism = hom(presentation_module, SQ, [g(x) for x in gens(R_b)])
  inverse_isomorphism = hom(SQ, presentation_module, [presentation_module[i] for i=1:ngens(SQ)])
  isomorphism.inverse_isomorphism = inverse_isomorphism

  if task == :store
    register_morphism!(isomorphism)
    register_morphism!(inverse_isomorphism)
  end
  task == :morphism && return isomorphism
  
  return presentation_module, isomorphism
end

@doc Markdown.doc"""
  change_generating_system(M::SubQuo{T}, N::SubQuo{T}, task::Symbol = :none) where {T}
If $M = N$ (mathematically, but with (possibly) different generating systems), return $\phi : M → N$ 
which is mathematically the identity. 
If `task == :inverse` also the inverse map is computed and cached (in the morphism).
If `task == :store` the inverse map is also cached in `M` and `N`.
"""
function change_generating_system(M::SubQuo{T}, N::SubQuo{T}, task::Symbol = :none) where {T}
  @assert M == N

  M_to_N = hom(M, N, [SubQuoElem(coordinates(m.repres, N), N) for m in gens(M)])

  if task == :store || task == :inverse
    N_to_M = hom(N, M, [SubQuoElem(coordinates(n.repres, M), M) for n in gens(N)])
    M_to_N.inverse_isomorphism = N_to_M
    N_to_M.inverse_isomorphism = M_to_N

    if task == :store
      register_morphism!(M_to_N) 
      register_morphism!(N_to_M)
    end
  end
  
  return M_to_N
end

mutable struct SubQuoHom{T1, T2} <: ModuleMap{T1, T2}
  matrix::MatElem
  header::Hecke.MapHeader
  im::Array{<:Any}
  inverse_isomorphism::ModuleMap

  function SubQuoHom(D::SubQuo, C::ModuleFP, im::Array{<:Any, 1})
    @assert length(im) == ngens(D)
    @assert all(x-> parent(x) === C, im)

    r = new{SubQuo, typeof(C)}()
    r.header = Hecke.MapHeader(D, C)
    r.header.image = x->image(r, x)
    r.header.preimage = x->preimage(r, x)
    r.im = im

    return r
  end

  function SubQuoHom(D::SubQuo, C::ModuleFP, mat::MatElem)
    @assert nrows(mat) == ngens(D)
    @assert ncols(mat) == ngens(C)
    if typeof(C) <: FreeMod
      hom = SubQuoHom(D, C, [FreeModuleElem(sparse_row(mat[i,:]), C) for i=1:ngens(D)])
      return hom
    else
      hom = SubQuoHom(D, C, [SubQuoElem(sparse_row(mat[i,:]), C) for i=1:ngens(D)])
      return hom
    end
  end
end

function Base.getproperty(f::SubQuoHom, s::Symbol)
  if s == :matrix
    if !isdefined(f, s)
      D = domain(f)
      C = codomain(f)
      R = base_ring(D)
      matrix = zero_matrix(R, ngens(D), ngens(C))
      for i=1:ngens(D), j=1:ngens(C)
        matrix[i,j] = f.im[i][j]
      end
      setfield!(f, s, matrix)
    end
  end
  return getfield(f,s)
end

function show_morphism(f::ModuleMap)
  display(f.matrix)
end

function hom_tensor(G::ModuleFP, H::ModuleFP, A::Array{ <: ModuleMap, 1})
  tG = get_special(G, :tensor_product)
  tG === nothing && error("both modules must be tensor products")
  tH = get_special(H, :tensor_product)
  tH === nothing && error("both modules must be tensor products")
  @assert length(tG) == length(tH) == length(A)
  @assert all(i-> domain(A[i]) == tG[i] && codomain(A[i]) == tH[i], 1:length(A))
  #gens of G are G[i][j] tensor G[h][l] for i != h and all j, l
  #such a pure tensor is mapped to A[i](G[i][j]) tensor A[h](G[j][l])
  #thus need the pure map - and re-create the careful ordering of the generators as in the 
  # constructor
  #store the maps? and possibly more data, like the ordeing
  decompose_G = get_special(G, :tensor_generator_decompose_function)
  pure_H = get_special(H, :tensor_pure_function)
  function map_gen(g) # Is there something that generalizes FreeModuleElem and SubQuoElem?
    g_decomposed = decompose_G(g)
    image_as_tuple = Tuple(f(x) for (f,x) in zip(A,g_decomposed))
    res = pure_H(image_as_tuple)
    return res
  end
  #error("not done yet")
  return hom(G, H, map(map_gen, gens(G)))
end

function hom_prod_prod(G::ModuleFP, H::ModuleFP, A::Array{ <: ModuleMap, 2})
  tG = get_special(G, :direct_product)
  tG === nothing && error("both modules must be direct products")
  tH = get_special(H, :direct_product)
  tH === nothing && error("both modules must be direct products")
  @assert length(tG) == size(A, 1) && length(tH) == size(A, 2)
  @assert all((i,j)-> domain(A[i,j]) == tG[i] && codomain(A[i,j]) == tH[j], Base.Iterators.ProductIterator((1:size(A, 1), 1:size(A, 2))))
  #need the canonical maps..., maybe store them as well?
  error("not done yet")
end
# hom(prod -> X), hom(x -> prod)
# if too much time: improve the hom(A, B) in case of A and/or B are products - or maybe not...
# tensor and hom functors for chain complex
# dual: ambig: hom(M, R) or hom(M, Q(R))?

@doc Markdown.doc"""
  coordinates(a::FreeModuleElem, SQ::SubQuo)
Compute a sparse row `r` such that `a` is a representative of `SubQuoElem(r, SQ)`.
If no such `r` exists an error is thrown.
"""
function coordinates(a::FreeModuleElem, SQ::SubQuo)
  if iszero(a)
    return sparse_row(base_ring(parent(a)))
  end
  #[SQ.sub[Val(:O), i] for i = 1:length(SQ.sub.O)]
  oscar_assure(SQ.sub.gens)
  if isdefined(SQ, :quo)
    #[SQ.quo[Val(:O), i] for i = 1:length(SQ.quo.O)]
    oscar_assure(SQ.quo.gens)
    generators = sum(SQ.sub, SQ.quo)
  else
    generators = SQ.sub
  end
  S = generators.gens.S
  #S = Singular.smodule{elem_type(base_ring(SQ.sub.gens.SF))}(base_ring(SQ.sub.gens.SF), [convert(SQ.sub.gens.SF, x) for x = generators]...)
  b = ModuleGens([a], SQ.sum.gens.SF)
  singular_assure(b)
  s, r = Singular.lift(S, b.S)
  if Singular.ngens(s) == 0 || iszero(s[1])
    error("elem not in module")
  end
  Rx = base_ring(SQ)
  return sparse_row(Rx, s[1], 1:ngens(SQ))
end


hom(D::SubQuo, C::ModuleFP, A::Array{<:Any, 1}) = SubQuoHom(D, C, A)

@doc Markdown.doc"""
  image(f::SubQuoHom, a::SubQuoElem)
Return $f(a)$.
"""
function image(f::SubQuoHom, a::SubQuoElem)
  # TODO matrix vector multiplication
  @assert a.parent === domain(f)
  i = zero(codomain(f))
  D = domain(f)
  b = a.coeffs
  #b = coordinates(a.repres, D)
  for (p,v) = b
    i += v*f.im[p]
  end
  return i
end

@doc Markdown.doc"""
  image(f::SubQuoHom, a::FreeModuleElem)
Return $f(a)$. `a` must represent an element in the domain of `f`.
"""
function image(f::SubQuoHom, a::FreeModuleElem)
  return image(f, SubQuoElem(a, domain(f)))
  #=i = zero(codomain(f))
  D = domain(f)
  b = coordinates(a, D)
  for (p,v) = b
    i += v*f.im[p]
  end
  return i=#
end

@doc Markdown.doc"""
  preimage(f::SubQuoHom, a::Union{SubQuoElem,FreeModuleElem})
Compute a preimage of `a` under `f`.
"""
function preimage(f::SubQuoHom, a::Union{SubQuoElem,FreeModuleElem})
  @assert parent(a) == codomain(f)
  D = domain(f)
  i = zero(D)
  b = coordinates(typeof(a) <: FreeModuleElem ? a : a.repres, image(f)[1])
  for (p,v) = b
    i += v*gen(D, p)
  end
  return i
end

(f::SubQuoHom)(a::FreeModuleElem) = image(f, a)
(f::SubQuoHom)(a::SubQuoElem) = image(f, a)

#ishom, homcompo missing

function iszero(a::SubQuoElem)
  C = parent(a)
  if !isdefined(C, :quo)
    return iszero(a.repres)
  end
  x = _reduce(convert(C.quo.gens.SF, a.repres), C.quo.std_basis.S)
  return iszero(x)
end

@doc Markdown.doc"""
  hom(F::FreeMod, G::FreeMod)
Return a subquotient $S$ such that $Hom(F,G) \cong S$ along with a function 
that converts elements from $S$ into morphisms $F → G$.
"""
function hom(F::FreeMod, G::FreeMod)
  @assert base_ring(F) == base_ring(G)
  GH = FreeMod(F.R, rank(F) * rank(G))
  GH.S = [Symbol("($i -> $j)") for i = F.S for j = G.S]

  #list is g1 - f1, g2-f1, g3-f1, ...
  X = Hecke.MapParent(F, G, "homomorphisms")
  n = ngens(F)
  m = ngens(G)
  R = base_ring(F)
  function im(x::FreeModuleElem)
    return hom(F, G, [FreeModuleElem(x.coords[R, (i-1)*m+1:i*m], G) for i=1:n])
  end
  function pre(h::FreeModuleHom)
    s = sparse_row(F.R)
    o = 0
    for i=1:n
      for (p,v) = h(gen(F, i)).coords
        push!(s.pos, o+p)
        push!(s.values, v)
      end
      o += m
    end
    return FreeModuleElem(s, GH)
  end
  to_hom_map = Hecke.MapFromFunc(im, pre, GH, X)
  Hecke.set_special(GH, :show => Hecke.show_hom, :hom => (F, G), :module_to_hom_map => to_hom_map)
  return GH, to_hom_map
end

@doc Markdown.doc"""
  kernel(h::FreeModuleHom)

Compute the kernel $K$ of `h` along with the inclusion morphism 
of $K$ into the domain of `h`.
"""
function kernel(h::FreeModuleHom)  #ONLY for free modules...
  G = domain(h)
  R = base_ring(G)
  if ngens(G) == 0
    s = sub(G, gens(G))
    return s, hom(s, G, gens(G))
  end
  g = map(h, basis(G))
  if isa(codomain(h), SubQuo)
    g = [x.repres for x = g]
    if isdefined(codomain(h), :quo)
      append!(g, collect(codomain(h).quo.gens))
    end
  end
  #TODO allow sub-quo here as well
  b = ModuleGens(g)
  k = syzygy_module(b)
  if isa(codomain(h), SubQuo)
    s = collect(k.sub.gens)
    k = sub(G, [FreeModuleElem(x.coords[R,1:dim(G)], G) for x = s])
  else
    #the syzygie_module creates a new free module to work in
    k = sub(G, [FreeModuleElem(x.coords, G) for x = collect(k.sub.gens)])
  end
  @assert k.F == G
  c = collect(k.sub.gens)
  return k, hom(k, parent(c[1]), c)
end

@doc Markdown.doc"""
  image(h::FreeModuleHom)

Compute the image of `h`. Return also the inclusion map into the codomain of `h`.
"""
function image(h::FreeModuleHom)
  si = [x for x = map(h, basis(domain(h))) if !iszero(x)]
  s = sub(codomain(h), si)
  return s, hom(s, codomain(h), si)
end

@doc Markdown.doc"""
  image(h::SubQuoHom)

Compute the image of `h`. Return also the inclusion map into the codomain of `h`.
"""
function image(h::SubQuoHom)
  if typeof(codomain(h)) <: FreeMod
    image_vector::Array{FreeModuleElem} = h.im
    s = sub(codomain(h), image_vector)
    return s, hom(s, codomain(h), image_vector)
  else
    image_vector2::Array{SubQuoElem} = h.im
    s = sub(codomain(h), image_vector2)
    return s, hom(s, codomain(h), image_vector2)
  end
  #s = sub(codomain(h), h.im)
  #return s, hom(s, codomain(h), h.im)
end

@doc Markdown.doc"""
  kernel(h::SubQuoHom)

Compute the kernel $K$ of `h` along with the inclusion morphism 
of $K$ into the domain of `h`.
"""
function kernel(h::SubQuoHom)
  D = domain(h)
  R = base_ring(D)
  F = FreeMod(R, ngens(D))
  hh = hom(F, codomain(h), map(h, gens(D)))
  k = kernel(hh)
  @assert domain(k[2]) === k[1]
  @assert codomain(k[2]) === F
  hh = hom(F, D, gens(D))
  im::Array{SubQuoElem,1} = map(x->hh(k[2](x)), gens(k[1]))
  k = sub(D, im)
  return k, hom(k, D, im)
end

@doc Markdown.doc"""
  free_resolution(F::FreeMod)

Compute a free resolution of the free module `F`.
"""
function free_resolution(F::FreeMod)
  return presentation(F)
end

@doc Markdown.doc"""
  free_resolution(S::SubQuo, limit::Int = -1)
Compute a free resolution of `S`. If `limit != -1` the free resolution
is only computed up to the `limit`-th free module.
"""
function free_resolution(S::SubQuo, limit::Int = -1)
  p = presentation(S)
  mp = [map(p, j) for j=1:length(p)]
  while true
    k, mk = kernel(mp[1])
    nz = findall(x->!iszero(x), gens(k))
    if length(nz) == 0 
      Z = FreeMod(base_ring(S), 0)
      Hecke.set_special(Z, :name => "Zero")
      h = hom(Z, domain(mp[1]), FreeModuleElem[])
      insert!(mp, 1, h)
      break
    elseif limit != -1 && length(mp) > limit
      break
    end
    F = FreeMod(base_ring(S), length(nz))
    g = hom(F, codomain(mk), collect(k.sub.gens)[nz])
    insert!(mp, 1, g)
  end
  return Hecke.ChainComplex(ModuleFP, mp, check = false, direction = :right)
end

function Hecke.ring(I::MPolyIdeal)
  return parent(gen(I, 1))
end

function free_resolution(I::MPolyIdeal)
  F = free_module(Hecke.ring(I), 1)
  S = sub(F, [x * gen(F, 1) for x = gens(I)])
  n = Hecke.find_name(I)
  if n !== nothing
    AbstractAlgebra.set_name!(S, string(n))
  end
  return free_resolution(S)
end

function free_resolution(Q::MPolyQuo)
  F = free_module(Q, 1)
  q = quo(F, [x * gen(F, 1) for x = gens(Q.I)])
  n = Hecke.find_name(Q)
  if n !== nothing
    AbstractAlgebra.set_name!(q, String(n))
  end
  return free_resolution(q)
end

function iszero(f::ModuleMap)
  return all(iszero, map(f, gens(domain(f))))
end

@doc Markdown.doc"""
  hom(M::ModuleFP, N::ModuleFP)
Return a subquotient $S$ such that $Hom(M,N) \cong S$ along with a function 
that converts elements from $S$ into morphisms $M → N$.
"""
function hom(M::ModuleFP, N::ModuleFP)
  p1 = presentation(M)
  p2 = presentation(N)
  k, mk = kernel(map(p2, 1))
  #Janko: have R^t1 -- g1 = map(p2, 0) -> R^t0 -> G
  #kernel g1: k -> R^t1
  #source: Janko's CA script: https://www.mathematik.uni-kl.de/~boehm/lehre/17_CA/ca.pdf
  F = FreeMod(base_ring(M), ngens(k))
  g2 = hom(F, codomain(mk), collect(k.sub.gens)) #not clean - but maps not (yet) working
  #step 2
  H_s0_t0, mH_s0_t0 = hom(domain(map(p1, 2)), domain(map(p2, 2)))
  H_s1_t1, mH_s1_t1 = hom(domain(map(p1, 1)), domain(map(p2, 1)))
  D, pro, emb = direct_product(H_s0_t0, H_s1_t1, task = :both)

  H_s1_t0, mH_s1_t0 = hom(domain(map(p1, 1)), domain(map(p2, 2)))

  delta = hom(D, H_s1_t0, [preimage(mH_s1_t0, map(p1, 1)*mH_s0_t0(pro[1](g))-mH_s1_t1(pro[2](g))*map(p2, 1)) for g = gens(D)])

  H_s0_t1, mH_s0_t1 = hom(domain(map(p1, 2)), domain(map(p2, 1)))
  H_s1_t2, mH_s1_t2 = hom(domain(map(p1, 1)), F)

  E, pr = direct_product(H_s0_t1, H_s1_t2, task = :prod)

  rho = hom(E, D, [emb[1](preimage(mH_s0_t0, mH_s0_t1(pr[1](g))*map(p2, 1))) + 
                   emb[2](preimage(mH_s1_t1, map(p1, 1)*mH_s0_t1(pr[1](g)) - mH_s1_t2(pr[2](g))*g2)) for g = gens(E)])
  #need quo(kern(delta), image(rho))                 
 
  kDelta = kernel(delta)

  #psi = kDelta[2]*pro[1]
  #psi = hom(kDelta[1], H_s0_t0, [psi(g) for g = gens(kDelta[1])])

  H = quo(sub(D, kDelta[1]), image(rho)[1])

  #x in ker delta: mH_s0_t0(pro[1](x)) should be a hom from M to N
  function im(x::SubQuoElem)
    @assert parent(x) == H
    #return SubQuoHom(M, N, mH_s0_t0(pro[1](x.repres)).matrix)
    return hom(M, N, [map(p2, 2)(mH_s0_t0(pro[1](x.repres))(preimage(map(p1, 2), g))) for g = gens(M)])
  end

  function pre(f::ModuleMap)
    @assert domain(f) == M
    @assert codomain(f) == N
    Rs0 = domain(map(p1, 2))
    Rt0 = domain(map(p2, 2))
    g = hom(Rs0, Rt0, [preimage(map(p2, 2), f(map(p1, 2)(g))) for g = gens(Rs0)])

    #return H(preimage(psi, (preimage(mH_s0_t0, g))).repres)
    return SubQuoElem(preimage(kDelta[2], emb[1](preimage(mH_s0_t0, g))).repres, H)
    #return SubQuoElem(emb[1](preimage(mH_s0_t0, g)), H) #???
  end
  to_hom_map = MapFromFunc(im, pre, H, Hecke.MapParent(M, N, "homomorphisms"))
  Hecke.set_special(H, :show => Hecke.show_hom, :hom => (M, N), :module_to_hom_map => to_hom_map)
  return H, to_hom_map
end

@doc Markdown.doc"""
  homomorphism(f::Union{SubQuoElem,FreeModuleElem})
If `f` is an element in a module created via `hom(M,N)` for some `M` and `N`, 
return the morphism $\phi : M → N$ that corresponds to `f`.
"""
function homomorphism(f::Union{SubQuoElem,FreeModuleElem})
  H = f.parent
  to_hom_map = get_special(H, :module_to_hom_map)
  to_hom_map === nothing && error("element doesn't live in a hom module")  
  return to_hom_map(f)
end

@doc Markdown.doc"""
  homomorphism_to_module_elem(H::ModuleFP, phi::ModuleMap)
Let `H` is created via `hom(M,N)` for some `M` and `N`. Return 
the element in `H` corresponding to `phi`.
"""
function homomorphism_to_module_elem(H::ModuleFP, phi::ModuleMap)
  to_hom_map = get_special(H, :module_to_hom_map)
  to_hom_map === nothing && error("module must be a hom module")
  map_to_hom = to_hom_map.g
  return map_to_hom(phi)
end

#TODO
#  replace the +/- for the homs by proper constructors for homs and direct sums
#  relshp to store the maps elsewhere

function *(h::ModuleMap, g::ModuleMap)
  @assert codomain(h) == domain(g)
  return hom(domain(h), codomain(g), [g(h(x)) for x = gens(domain(h))])
end
-(h::FreeModuleHom, g::FreeModuleHom) = hom(domain(h), codomain(h), [h(x) - g(x) for x = gens(domain(h))])
+(h::FreeModuleHom, g::FreeModuleHom) = hom(domain(h), codomain(h), [h(x) + g(x) for x = gens(domain(h))])


@doc Markdown.doc"""
  restrict_codomain(H::ModuleMap, M::SubQuo)
Return, if possible, a homomorphism, which is mathematically identical to `H`,
but has codomain `M`. `M` has to be a submodule of the codomain of `H`.
"""
function restrict_codomain(H::ModuleMap, M::SubQuo)
  @assert typeof(codomain(H)) <: SubQuo
  return hom(domain(H), M, map(v -> SubQuoElem(v, M), map(x -> H(x).repres, gens(domain(H)))))
end

@doc Markdown.doc"""
  restrict_domain(H::SubQuoHom, M::SubQuo)

Restrict the morphism `H` to `M`. For this `M` has to be a submodule
of the domain of `H`. The relations of `M` must be the relations of 
the domain of `H`.
"""
function restrict_domain(H::SubQuoHom, M::SubQuo)
  for i in M.outgoing_morphisms
    if codomain(i) === domain(H)
      return i*H
    end
  end
  # else there is no cached map
  i = sub(domain(H), gens(M), :store, true)[2]
  return i*H
end

@doc Markdown.doc"""
  Base.inv(H::ModuleMap)
Compute $H^{-1}$. `H` must be bijective.
"""
function Base.inv(H::ModuleMap)
  if isdefined(H, :inverse_isomorphism)
    return H.inverse_isomorphism
  end
  @assert isbijective(H)
  N = domain(H)
  M = codomain(H)

  Hinv = hom(M,N, [preimage(H,m) for m in gens(M)])
  Hinv.inverse_isomorphism = H
  H.inverse_isomorphism = Hinv

  return Hinv
end

##################################################
# direct product
##################################################
@doc Markdown.doc"""
  direct_product(F::FreeMod{T}...; task::Symbol = :sum)

Given free modules $F_i$ compute the direct product $P := F_1\oplus \cdots \oplus F_n$.
If `task` is set to ":prod", an array of maps $\phi_1, \cdot, \phi_n$ is returned such
that $\phi_i$ is the canonical projection $P → F_i$.
If `task` is set to ":sum", an array of maps $\psi_1, \cdot, \psi_n$ is returned such 
that $\psi_i$ is the canonical injection $F_i → P$.
If `task` is set to ":both", both, the array of projections and the array of injections,
are returned (with projections first).
"""
function direct_product(F::FreeMod{T}...; task::Symbol = :sum) where {T}
  R = base_ring(F[1])
  G = FreeMod(R, Base.sum([rank(f) for f = F]))
  G.S = []
  for i = 1:length(F)
    s = "("
    for j=1:i-1
      s *= "0, "
    end
    e = ""
    if i<length(F)
      e*=", "
    end
    for j=i+1:length(F)-1
      e *= "0, "
    end
    if i<length(F)
      e *= "0"
    end
    e*=")"

    for t = F[i].S
      push!(G.S, Symbol(s*string(t)*e))
    end
  end
  Hecke.set_special(G, :show => Hecke.show_direct_product, :direct_product => F)
  emb = []
  pro = []
  i = 0
  for f = F
    if task in [:sum, :both]
      push!(emb, hom(f, G, [gen(G, j+i) for j=1:ngens(f)]))
    end
    if task in [:prod, :both]
      push!(pro, hom(G, f, vcat(elem_type(f)[zero(f) for j=1:i], gens(f), elem_type(f)[zero(f) for j=i+ngens(f)+1:ngens(G)])))
    end
    i += ngens(f)
  end
  if task == :none
    return G
  elseif task == :sum
    return G, emb
  elseif task == :prod
    return G, pro
  elseif task == :both
    return G, pro, emb
  end
end

@doc Markdown.doc"""
  direct_product(G::ModuleFP...; task::Symbol = :none)

Given modules $G_i$ compute the direct product $P := G_1\oplus \cdots \oplus G_n$.
If `task` is set to ":prod", an array of maps $\phi_1, \cdot, \phi_n$ is returned such
that $\phi_i$ is the canonical projection $P → G_i$.
If `task` is set to ":sum", an array of maps $\psi_1, \cdot, \psi_n$ is returned such 
that $\psi_i$ is the canonical injection $G_i → P$.
If `task` is set to ":both", both, the array of projections and the array of injections,
are returned (with projections first).
"""
function direct_product(G::ModuleFP...; task::Symbol = :none)
  F, pro, mF = direct_product([free_module(x) for x = G]..., task = :both)
  s, emb_sF = sub(F, vcat([[mF[i](y) for y = gens(G[i], free_module(G[i]))] for i=1:length(G)]...), :both)
  q = vcat([[mF[i](y) for y = rels(G[i])] for i=1:length(G)]...)
  pro_quo = nothing
  if length(q) != 0
    s, pro_quo = quo(s, q, :both)
  end
  if task == :none
    return s
  end
  if task == :prod || task != :sum
    if pro_quo === nothing
      for i=1:length(pro)
        pro[i] = hom(s, G[i], [G[i](pro[i](emb_sF(gen))) for gen in gens(s)])
      end
    else
      for i=1:length(pro)
        pro[i] = hom(s, G[i], [G[i](pro[i](emb_sF(preimage(pro_quo,gen)))) for gen in gens(s)])
      end
    end
    if task == :prod
      return s, pro
    end
  end
  if task == :sum || task != :prod
    if pro_quo === nothing
      for i=1:length(mF)
        mF[i] = hom(G[i], s, [preimage(emb_sF, mF[i](typeof(G) <: FreeMod ? g : g.repres)) for g in gens(G[i])])
      end
    else
      for i=1:length(mF)
        mF[i] = hom(G[i], s, [pro_quo(preimage(emb_sF, mF[i](typeof(G) <: FreeMod ? g : g.repres))) for g in gens(G[i])])
      end
    end
    if task == :sum
      return s, mF
    else
      return s, pro, mF
    end
  end
end
⊕(M::ModuleFP...) = direct_product(M..., task = :none)


function Hecke.canonical_injection(G::ModuleFP, i::Int)
  H = Hecke.get_special(G, :direct_product)
  if H === nothing
    error("module not a direct product")
  end
  0<i<= length(H) || error("index out of bound")
  j = i == 1 ? 0 : sum(ngens(H[l]) for l=1:i-1) -1
  return hom(H[i], G, [G[l+j] for l = 1:ngens(H[i])])
end

function Hecke.canonical_projection(G::ModuleFP, i::Int)
  H = Hecke.get_special(G, :direct_product)
  if H === nothing
    error("module not a direct product")
  end
  0<i<= length(H) || error("index out of bound")
  j = i == 1 ? 0 : sum(ngens(H[l]) for l=1:i-1) 
  return hom(G, H[i], vcat([zero(H[i]) for l=1:j], gens(H[i]), [zero(H[i]) for l=1+j+ngens(H[i]):ngens(G)]))
end
    
##################################################
# Tensor
##################################################

@doc Markdown.doc"""
  tensor_product(G::FreeMod...; task::Symbol = :none)

Given free modules $G_i$ compute the tensor product $G_1\otimes \cdots \otimes G_n$.
If `task` is set to ":map", a map $\phi$ is returned that
maps tuples in $G_1 \times \cdots \times G_n$ to pure tensors
$g_1 \otimes \cdots \otimes g_n$. The map admits a preimage as well.
"""
function tensor_product(G::FreeMod...; task::Symbol = :none)
  s = G[1].S
  t = [[x] for x = 1:ngens(G[1])]
  for H = G[2:end]
    s = [Symbol("$x \\otimes $y") for x = s  for y = H.S]
    t = [push!(deepcopy(x), y) for x = t  for y = 1:ngens(H)]
  end

  F = FreeMod(G[1].R, prod([rank(g) for g in G]))
  F.S = s
  Hecke.set_special(F, :show => Hecke.show_tensor_product, :tensor_product => G)
  if task == :none
    return F
  end

  function pure(g::FreeModuleElem...)
    @assert length(g) == length(G)
    @assert all(i -> parent(g[i]) == G[i], 1:length(G))
    z = [[x] for x = g[1].coords.pos]
    zz = g[1].coords.values
    for h = g[2:end]
      zzz = Array{Int, 1}[]
      zzzz = elem_type(F.R)[]
      for i = 1:length(z)
        for (p, v) = h.coords
          push!(zzz, push!(deepcopy(z[i]), p))
          push!(zzzz, zz[i]*v)
        end
      end
      z = zzz
      zz = zzzz
    end
    return FreeModuleElem(sparse_row(F.R, [findfirst(x->x == y, t) for y = z], zz), F)
  end
  function pure(T::Tuple)
    return pure(T...)
  end
  function inv_pure(e::FreeModuleElem)
    if length(e.coords.pos) == 0
      return Tuple(zero(g) for g = G)
    end
    @assert length(e.coords.pos) == 1
    @assert isone(e.coords.values[1])
    return Tuple(gen(G[i], t[e.coords.pos[1]][i]) for i = 1:length(G))
  end

  Hecke.set_special(F, :tensor_pure_function => pure, :tensor_generator_decompose_function => inv_pure)

  return F, MapFromFunc(pure, inv_pure, Hecke.TupleParent(Tuple([g[0] for g = G])), F)
end

⊗(G::ModuleFP...) = tensor_product(G..., task = :none)

function free_module(F::FreeMod)
  return F
end

function free_module(F::SubQuo)
  return F.F
end

function gens(F::FreeMod, G::FreeMod)
  @assert F == G
  return gens(F)
end
function gens(F::SubQuo, G::FreeMod)
  @assert F.F == G
  return [FreeModuleElem(x.repres.coords, G) for x = gens(F)]
end
rels(F::FreeMod) = elem_type(F)[]
rels(F::SubQuo) = isdefined(F, :quo) ? collect(F.quo.gens) : elem_type(F.F)[]

@doc Markdown.doc"""
    tensor_product(G::ModuleFP...; task::Symbol = :none)

Given modules $G_i$ compute the tensor product $G_1\otimes \cdots \otimes G_n$.
If `task` is set to ":map", a map $\phi$ is returned that
maps tuples in $G_1 \times \cdots \times G_n$ to pure tensors
$g_1 \otimes \cdots \otimes g_n$. The map admits a preimage as well.
"""
function tensor_product(G::ModuleFP...; task::Symbol = :none)
  F, mF = tensor_product([free_module(x) for x = G]..., task = :map)
  # We want to store a dict where the keys are tuples of indices and the values
  # are the corresponding pure vectors (i.e. a tuple (2,1,5) represents the 
  # 2nd, 1st and 5th generator of the 1st, 2nd and 3rd module, which we are 
  # tensoring. The corresponding value is then G[1][2] ⊗ G[2][1] ⊗ G[2][5]). 
  corresponding_tuples_as_indices = vec([x for x = Base.Iterators.ProductIterator(Tuple(1:ngens(x) for x = G))])
  # In corresponding_tuples we store tuples of the actual generators, so in 
  # the example above we would store (G[1][2], G[2][1], G[2][5]).
  corresponding_tuples = map(index_tuple -> Tuple(map(index -> G[index][index_tuple[index]],1:length(index_tuple))), corresponding_tuples_as_indices)

  generating_tensors = map(mF, map(tuple -> map(x -> typeof(parent(x)) <: FreeMod ? x : x.repres, tuple), corresponding_tuples))
  s, emb = sub(F, generating_tensors, :map)
  #s, emb = sub(F, vec([mF(x) for x = Base.Iterators.ProductIterator(Tuple(gens(x, free_module(x)) for x = G))]), :map)
  q = vcat([vec([mF(x) for x = Base.Iterators.ProductIterator(Tuple(i == j ? rels(G[i]) : gens(free_module(G[i])) for i=1:length(G)))]) for j=1:length(G)]...) 
  local projection_map
  if length(q) != 0
    s, projection_map = quo(s, q, :map)
  end

  tuples_pure_tensors_dict = IdDict(zip(corresponding_tuples_as_indices, gens(s)))
  Hecke.set_special(s, :show => Hecke.show_tensor_product, :tensor_product => G)
  if task == :none
    return s
  else
    function pure(tuple_elems::Union{SubQuoElem,FreeModuleElem}...)
      coeffs_tuples = vec([x for x = Base.Iterators.ProductIterator(Tuple(x.coeffs for x = tuple_elems))])
      res = zero(s)
      for coeffs_tuple in coeffs_tuples
        indices = map(x -> x[1], coeffs_tuple)
        coeff_for_pure = prod(map(x -> x[2], coeffs_tuple))
        res += coeff_for_pure*tuples_pure_tensors_dict[indices]
      end
      return res
    end
    function pure(T::Tuple)
      return pure(T...)
    end

    decompose_generator = function(v::SubQuoElem)
      i = index_of_gen(v)
      return corresponding_tuples[i]
    end

    Hecke.set_special(s, :tensor_pure_function => pure, :tensor_generator_decompose_function => decompose_generator)

    return s, MapFromFunc(pure, Hecke.TupleParent(Tuple([g[0] for g = G])), s)
  end
end

#############################
# Tor
#############################
@doc Markdown.doc"""
  tensor_product(P::ModuleFP, C::Hecke.ChainComplex{ModuleFP})
Apply $P⊗-$ to `C`.
"""
function tensor_product(P::ModuleFP, C::Hecke.ChainComplex{ModuleFP})
  tensor_chain = Hecke.map_type(C)[]
  tensor_modules = [tensor_product(P, domain(C.maps[1]), task=:store)[1]]
  tensor_modules = vcat(tensor_modules, [tensor_product(P, codomain(f), task=:store)[1] for f in C.maps])

  for i=1:length(C)
    A = tensor_modules[i]
    B = tensor_modules[i+1]

    push!(tensor_chain, hom_tensor(A,B,[identity_map(P), map(C,i)]))
  end

  return Hecke.ChainComplex(ModuleFP, tensor_chain)
end

@doc Markdown.doc"""
  tensor_product(C::Hecke.ChainComplex{ModuleFP}, P::ModuleFP)
Apply $-⊗P$ to `C`.
"""
function tensor_product(C::Hecke.ChainComplex{ModuleFP}, P::ModuleFP)
  tensor_chain = Hecke.map_type(C)[]
  tensor_modules = [tensor_product(domain(C.maps[1]), P, task=:store)[1]]
  tensor_modules = vcat(tensor_modules, [tensor_product(codomain(f), P, task=:store)[1] for f in C.maps])

  for i=1:length(C)
    A = tensor_modules[i]
    B = tensor_modules[i+1]

    push!(tensor_chain, hom_tensor(A,B,[map(C,i), identity_map(P)]))
  end

  return Hecke.ChainComplex(ModuleFP, tensor_chain)
end

@doc Markdown.doc"""
  tor(M::ModuleFP, N::ModuleFP, i::Int)
Compute $Tor_i(M,N)$.
"""
function tor(M::ModuleFP, N::ModuleFP, i::Int)
  free_res = free_resolution(M)[1:end-2]
  lifted_resolution = tensor_product(free_res, N) #TODO only three homs are neccessary
  return homology(lifted_resolution,length(lifted_resolution)-i)
end

#TODO, mF
#  (hom lift) => hom and tensor functor
#  filtrations
#  more constructors
#################################################
#
#################################################
@doc Markdown.doc"""
  lift_homomorphism_contravariant(Hom_MP::ModuleFP, Hom_NP::ModuleFP, phi::ModuleMap)
Let $Hom_MP = Hom(M,P)$, $Hom_NP = Hom(N,P)$ and $phi = φ : N → M$ a morphism.
Compute $φ^{\ast} : Hom(M,P) → Hom(N,P)$.
"""
function lift_homomorphism_contravariant(Hom_MP::ModuleFP, Hom_NP::ModuleFP, phi::ModuleMap)
  # phi : N -> M
  M_P = get_special(Hom_MP, :hom)
  M_P === nothing && error("Both modules must be hom modules")
  N_P = get_special(Hom_NP, :hom)
  N_P === nothing && error("Both modules must be hom modules")
  
  @assert M_P[2] === N_P[2]
  M,P = M_P
  N,_ = N_P
  @assert domain(phi) === N
  @assert codomain(phi) === M
  
  phi_lifted = hom(Hom_MP, Hom_NP, [homomorphism_to_module_elem(Hom_NP, phi*homomorphism(f)) for f in gens(Hom_MP)])
  return phi_lifted
end

@doc Markdown.doc"""
  lift_homomorphism_covariant(Hom_PM::ModuleFP, Hom_PN::ModuleFP, phi::ModuleMap)
Let $Hom_PM = Hom(P,M)$, $Hom_PN = Hom(P,N)$ and $phi = φ : M → N$ a morphism.
Compute $φ_{\ast} : Hom(P,M) → Hom(P,N)$.
"""
function lift_homomorphism_covariant(Hom_PM::ModuleFP, Hom_PN::ModuleFP, phi::ModuleMap)
  # phi : M -> N
  P_M = get_special(Hom_PM, :hom)
  P_M === nothing && error("Both modules must be hom modules")
  P_N = get_special(Hom_PN, :hom)
  P_N === nothing && error("Both modules must be hom modules")

  @assert P_M[1] === P_N[1]
  P,M = P_M
  _,N = P_N
  @assert domain(phi) === M
  @assert codomain(phi) === N

  if iszero(Hom_PN)
    return hom(Hom_PM, Hom_PN, [zero(Hom_PN) for _=1:ngens(Hom_PM)])
  end
  phi_lifted = hom(Hom_PM, Hom_PN, [homomorphism_to_module_elem(Hom_PN, homomorphism(f)*phi) for f in gens(Hom_PM)])
  return phi_lifted
end

@doc Markdown.doc"""
  hom_functor(P::ModuleFP, C::Hecke.ChainComplex{ModuleFP})
Apply $Hom(P,-)$ to `C`. Return the lifted chain complex.
"""
function hom_functor(P::ModuleFP, C::Hecke.ChainComplex{ModuleFP})
  hom_chain = Hecke.map_type(C)[]
  hom_modules = [hom(P, domain(C.maps[1]))]
  hom_modules = vcat(hom_modules, [hom(P, codomain(f)) for f = C.maps])

  for i=1:length(C)
    A = hom_modules[i][1]
    B = hom_modules[i+1][1]

    push!(hom_chain, lift_homomorphism_covariant(A,B,map(C,i)))
  end
  return Hecke.ChainComplex(ModuleFP, hom_chain)
end

@doc Markdown.doc"""
  hom_functor(C::Hecke.ChainComplex{ModuleFP}, P::ModuleFP)
Apply $Hom(-,P)$ to `C`. Return the lifted chain complex.
"""
function hom_functor(C::Hecke.ChainComplex{ModuleFP}, P::ModuleFP)
  hom_chain = Hecke.map_type(C)[]
  hom_modules = [hom(domain(C.maps[1]),P)]
  hom_modules = vcat(hom_modules, [hom(codomain(f), P) for f = C.maps])

  for i=1:length(C)
    A = hom_modules[i][1]
    B = hom_modules[i+1][1]

    push!(hom_chain, lift_homomorphism_contravariant(B,A,map(C,i)))
  end
  return Hecke.ChainComplex(ModuleFP, reverse(hom_chain))
end

#############################
@doc Markdown.doc"""
  homology(C::Hecke.ChainComplex{ModuleFP})
Compute all homology groups of `C`.
"""
function homology(C::Hecke.ChainComplex{ModuleFP})
  H = SubQuo[]
  for i=1:length(C)-1
    push!(H, quo(kernel(C.maps[i+1])[1], image(C.maps[i])[1]))
  end
  return H
end

@doc Markdown.doc"""
  homology(C::Hecke.ChainComplex{ModuleFP}, i::Int)
Compute the `i`-th homology of `C`.
"""
function homology(C::Hecke.ChainComplex{ModuleFP}, i::Int)
  @assert length(C) > 0 #TODO we need actually only the base ring
  if i == 0
    return kernel(map(C,1))[1]
  elseif i == length(C)
    return quo(obj(C,i),image(map(C,i))[1])
  elseif i < 0 || i > length(C)
    return FreeMod(base_ring(obj(C,1)),0)
  else
    return quo(kernel(map(C,i+1))[1], image(map(C,i))[1])
  end
end

#############################
# Ext
#############################
@doc Markdown.doc"""
  ext(M::ModuleFP, N::ModuleFP, i::Int)
Compute $Ext^i(M,N)$.
"""
function ext(M::ModuleFP, N::ModuleFP, i::Int)
  free_res = free_resolution(M)[1:end-2]
  lifted_resolution = hom_functor(free_res, N) #TODO only three homs are neccessary
  return homology(lifted_resolution,i)
end

#############################
# TODO ?
#############################
@doc Markdown.doc"""
  map_canonically(M::SubQuo, v::SubQuoElem)
Map the element `v` to an elemet of the module `M` using cached 
canonical homomorphisms between the parent Module of `v` and `M`.
"""
function map_canonically(M::SubQuo, v::SubQuoElem)
  N = parent(v)
  if N===M
    return v
  end

  # Breadth-First Search to find path to N:
  parent_hom = IdDict{SubQuo,ModuleMap}()
  modules = Set([M])
  found_N = false
  for A in modules
    for H in A.ingoing_morphisms
      B = domain(H)
      if B!==A # on trees "B!==A" is enough!
        if !(B in modules)
          parent_hom[B] = H
          push!(modules,B)
        end
      end
      if B===N
        found_N = true
        break
      end
    end
    if found_N
      break
    end
  end
  if !found_N
    throw(DomainError("There is no path of canonical homomorphisms between the modules!"))
  end
  result = v
  A = N
  while A !== M
    H = parent_hom[A]
    result = H(result)
    A = codomain(H)
  end
  return result
end

function all_canonical_maps(M::SubQuo, N::SubQuo)
  # from N to M

  all_paths = []

  function helper_dfs(U::SubQuo, D::SubQuo, visited::Set, path::Vector)
    if U === D
      push!(all_paths, path)
      return
    end
    for neighbor_morphism in U.outgoing_morphisms
      if !(neighbor_morphism in visited)

        #push!(visited, neighbor_morphism)
        #push!(path, neighbor_morphism)
        #helper_dfs(codomain(neighbor_morphism), D, visited, path)
        helper_dfs(codomain(neighbor_morphism), D, union(visited, Set([neighbor_morphism])), union(path, [neighbor_morphism]))
        #helper_dfs(codomain(neighbor_morphism), D, visited, union(path, [neighbor_morphism]))
      end
    end
  end

  helper_dfs(N, M, Set(), [])

  morphisms = Array{ModuleMap, 1}()
  for path in all_paths
    phi = identity_map(N)
    for h in path
      phi = phi*h
    end
    push!(morphisms, phi)
  end

  return morphisms
end

#############################
# Useful functions
#############################

@doc Markdown.doc"""
  register_morphism!(f::ModuleMap)
Cache the morphism `f` in the corresponding caches of the domain and codomain of `f`.
"""
function register_morphism!(f::ModuleMap)
  push!(domain(f).outgoing_morphisms, f)
  push!(codomain(f).ingoing_morphisms, f)
end

#############################
#TODO move to Hecke
#  re-evaluate and use or not
function differential(c::Hecke.ChainComplex, i::Int)
  return map(c,length(c)-i)
end

function module_in_complex(c::Hecke.ChainComplex, i::Int)
  return obj(c,length(c)-i)
end

getindex(c::Hecke.ChainComplex, i::Int) = module_in_complex(c,i)

function Base.getindex(r::Hecke.SRow, u::UnitRange)
  R = base_ring(r)
  s = sparse_row(R)
  shift = 1-first(u)
  for (p,v) = r
    if p in u
      push!(s.pos, p+shift)
      push!(s.values, v)
    end
  end
  return s
end

function Base.getindex(r::Hecke.SRow, R::AbstractAlgebra.Ring, u::UnitRange)
  s = sparse_row(R)
  shift = 1-first(u)
  for (p,v) = r
    if p in u
      push!(s.pos, p+shift)
      push!(s.values, v)
    end
  end
  return s
end

function getindex(a::Hecke.SRow, b::AbstractArray{Int, 1})
  if length(a.pos) == 0
    return a
  end
  m = minimum(b)
  b = sparse_row(parent(a.values[1]))
  for (k,v) = a
    if k in b
      push!(b.pos, k-b+1)
      push!(b.values, v)
    end
  end
  return b
end

@doc Markdown.doc"""
  sparse_row(A::MatElem)
Convert `A` to a sparse row. 
`nrows(A) == 1` must hold.
"""
function sparse_row(A::MatElem)
  @assert nrows(A) == 1
  return Hecke.sparse_matrix(A)[1]
end

@doc Markdown.doc"""
  dense_row(r::Hecke.SRow, n::Int)
Convert `r[1:n]` to a dense row, that is an AbstractAlgebra matrix.
"""
function dense_row(r::Hecke.SRow, n::Int)
  R = base_ring(r)
  A = zero_matrix(R, 1, n)
  for i in intersect(r.pos, 1:n)
    A[1,i] = r[i]
  end
  return A
end

##############################
#should be in Singular.jl
function Singular.intersection(a::Singular.smodule, b::Singular.smodule)
  c = base_ring(a)
  return Singular.Module(c, Singular.libSingular.id_Intersection(a.ptr, b.ptr, c.ptr))
end

function _reduce(a::Singular.smodule, b::Singular.smodule)
  @assert b.isGB
  p = Singular.libSingular.p_Reduce(a.ptr, b.ptr, base_ring(b).ptr)
  return Singular.Module(base_ring(b), p)
end

function _reduce(a::Singular.svector, b::Singular.smodule)
  @assert b.isGB
  p = _reduce(Singular.Module(base_ring(b), a), b)[1]
  return Singular.Module(base_ring(b), p)[1]
end

#TODO: tensor_product from Raul's H is broken


######################################
# Migrating test
######################################
@doc Markdown.doc"""
  projection(F::FreeMod, indices::AbstractArray)
Return the canonical projection from $F = R^I$ to $R^(indices)$ where $indices ⊂ I$.
"""
function projection(F::FreeMod, indices::AbstractArray)
  @assert all(x -> x <= ngens(F), indices)
  @assert length(Set(indices)) == length(indices) # unique indices
  R = base_ring(F)
  G = FreeMod(R, length(indices))
  return hom(F, G, [i in indices ? G[findfirst(x->x==i,indices)] : zero(G) for i=1:ngens(F)])
end

@doc Markdown.doc"""
    preimage_SQ(H::SubQuoHom,elems::Vector{SubQuoElem{T}}, task::Symbol = :none) where {T}
Return the preimage of the submodule generated by the Elements $elems$ under $H$
as a subquotient, as well as the injection homomorphism into the domain of $H$.
"""
function preimage_SQ(H::SubQuoHom,elems::Vector{SubQuoElem{T}}, task::Symbol = :none) where {T}
  if length(elems)==0
      throw(ArgumentError("too few arguments"))
  end
  R = base_ring(domain(H))
  row_length = ngens(codomain(H))
  submod = vcat((dense_row(e.coeffs, row_length) for e in elems)...)
  C = present(codomain(H)).quo.matrix
  A = vcat(H.matrix, C, submod)
  G = FreeMod(R, nrows(A))
  A = FreeModuleHom(G, FreeMod(R, ncols(A)), A)
  #K = kernel(A)
  K,kernel_injection = kernel(A)
  N = domain(H)
  n = ngens(N)
  generators = Array{SubQuoElem{T},1}()
  projection_map = projection(G, 1:n)
  for i=1:ngens(K)
      coeffs_for_new = projection_map(kernel_injection(K[i])).coords
      if isempty(coeffs_for_new)
        continue
      end
      new = SubQuoElem(coeffs_for_new, N)
      if !iszero(new)
          push!(generators, new)
      end
  end
  if length(generators)==0
      push!(generators,zero(N))
  end

  
  preimage, emb = sub(domain(H), generators, :map)
  preimage_pruned, prune_isomorphism = prune(preimage)
  if task != :none
    return preimage_pruned, prune_isomorphism*emb
  else
    return preimage_pruned
  end
end

# should probably be deprecated
function prune(M::SubQuo)
  local M_std
  if isdefined(M, :quo)
    M_std = SubQuo(SubModuleOfFreeModule(M.F, M.sub.std_basis), M.quo)
  else
    M_std = SubQuo(SubModuleOfFreeModule(M.F, M.sub.std_basis))
  end
  if ngens(M_std) < ngens(M)
    return M_std, change_generating_system(M_std, M)
  else
    return M, identity_map(M)
  end
end

@doc Markdown.doc"""
  matrix_kernel(A::MatElem)
Compute the kernel of `A` where `A` is considered as the correponding morphism
between free modules.
"""
function matrix_kernel(A::MatElem)
  R = base_ring(A)
  F_domain = FreeMod(R, nrows(A))
  F_codomain = FreeMod(R, ncols(A))

  phi = FreeModuleHom(F_domain, F_codomain, A)
  _, inclusion = kernel(phi)
  return inclusion.matrix
end

@doc Markdown.doc"""
  simplify_subquotient(M::SubQuo)
Simplify the given subquotient `M` and return the simplified subquotient `N` along
with the injection map $N --> M$ and the projection map $M --> N$.
"""
function simplify_subquotient(M::SubQuo)
  function unit_vector_in_relations(i::Int, M::SubQuo)
    if !isdefined(M, :quo)
      return false
    end
    reduced_unit_vector = _reduce(convert(M.quo.gens.SF, M.F[i]), M.quo.std_basis.S)
    return iszero(reduced_unit_vector)
  end

  function delete_rows(A::MatElem, to_delete::Array{Int,1})
    Mat = A[setdiff(1:nrows(A),to_delete),:]
    return Mat
  end
  function delete_columns(A::MatElem, to_delete::Array{Int,1})
    return delete_rows(A', to_delete)'
  end

  function assign_row!(A::MatElem, v::Vector, row_index::Int)
    if length(v) != size(A)[2]
      throw(DimensionMismatch("Different row lengths"))
    end
    for i=1:length(v)
      A[row_index,i] = v[i]
    end
    return A
  end

  function assign_row!(A::MatElem, v::MatElem, row_index::Int)
    if size(v)[1] > 1
      throw(DimensionMismatch("Expected row vector"))
    end
    if length(v) != size(A)[2]
      throw(DimensionMismatch("Different row lengths"))
    end
    for i=1:length(v)
      A[row_index,i] = v[1,i]
    end
    return A
  end

  function rows_to_delete(A::MatElem, max_index::Int)
    to_delete_indices::Array{Int,1} = []
    corresponding_row_index::Array{Int,1} = []
    K = matrix_kernel(A)
    for i=1:size(K)[1], j=1:max_index
      if isunit(K[i,j])
        deletion_possible = true
        for k in to_delete_indices
          if !iszero(K[i,k])
            deletion_possible = false
            break
          end
        end
        if deletion_possible
          push!(to_delete_indices, j)
          push!(corresponding_row_index, i)
        end
      end
    end
    return to_delete_indices, corresponding_row_index, K
  end

  R = base_ring(M)
  #remove columns

  M_generators = M.sub.matrix
  M_relations = isdefined(M, :quo) ? M.quo.matrix : zero_matrix(R, 1,ncols(M_generators))

  to_delete::Array{Int,1} = []
  for i=1:size(M_relations)[2]
    if unit_vector_in_relations(i, M)
      push!(to_delete, i)
    end
  end

  new_generators = delete_columns(M_generators, to_delete)
  new_relations = delete_columns(M_relations, to_delete)

  to_delete,_,_ = rows_to_delete(vcat(new_generators, new_relations)',size(new_relations)[2])

  new_generators = delete_columns(new_generators, to_delete)
  new_relations = delete_columns(new_relations, to_delete)

  #remove rows
  #simplify relations
  to_delete,_,_ = rows_to_delete(new_relations, size(new_relations)[1])

  new_relations = delete_rows(new_relations, to_delete)

  #simplify generators
  to_delete, corresponding_row, K_gen = rows_to_delete(vcat(new_generators, new_relations), size(new_generators)[1])


  injection_matrix = delete_rows(identity_matrix(R, size(M_generators)[1]), to_delete)
  projection_matrix = zero_matrix(R, size(M_generators)[1], size(K_gen)[2]-length(to_delete))
  for i=1:size(M_generators)[1]
    if i in to_delete
      index = findfirst(x -> x==i, to_delete)
      assign_row!(projection_matrix, R(-1)*R(inv(coeff(K_gen[corresponding_row[index],i], 1)))*delete_columns(K_gen[corresponding_row[index],:], to_delete), i)
    else
      unit_vector_index = i-length(filter(x -> x < i, to_delete))
      unit_vector = [j == unit_vector_index ? R(1) : R(0) for j=1:size(projection_matrix)[2]]
      assign_row!(projection_matrix, unit_vector, i)
    end
  end

  new_generators = delete_rows(new_generators, to_delete)

  if length(new_generators)==0
    zero_module = FreeMod(R,0)
    injection = FreeModuleHom(zero_module, M, [])
    projection = SubQuoHom(M, zero_module, [zero(zero_module) for i=1:ngens(M)])
    # TODO early return or register morphisms?
    return zero_module,injection,projection
  else
    SQ = iszero(new_relations) ? SubQuo(SubModuleOfFreeModule(new_generators)) : SubQuo(new_generators, new_relations)
    injection = SubQuoHom(SQ, M, injection_matrix)
    projection = SubQuoHom(M, SQ, projection_matrix[:,1:size(projection_matrix)[2]-size(new_relations)[1]])
  end
  register_morphism!(injection)
  register_morphism!(projection)
  injection.inverse_isomorphism = projection
  projection.inverse_isomorphism = injection

  #=if isgraded(M)
    ishomogeneous_function_lookup_table[SQ] = x -> custom_ishomogeneous(injection(x))
    degree_function_lookup_table[SQ] = x -> custom_degree(injection(x))
  end=#

  return SQ,injection,projection
end

######################################
# Not only for testing
######################################
@doc Markdown.doc"""
  matrix_to_map(A::MatElem)
Converts a given n×m-matrix into the corresponding morphism $A : R^n → R^m$.
"""
function matrix_to_map(A::MatElem)
  R = base_ring(A)
  F_domain = FreeMod(R, nrows(A))
  F_codomain = FreeMod(R, ncols(A))

  phi = FreeModuleHom(F_domain, F_codomain, A)
  return phi
end

@doc Markdown.doc"""
  isinjective(f::ModuleMap)
Test if `f` is injective.
"""
function isinjective(f::ModuleMap)
  return iszero(kernel(f)[1])
end

@doc Markdown.doc"""
  issurjective(f::ModuleMap)
Test if `f` is surjective.
"""
function issurjective(f::ModuleMap)
  return image(f)[1] == codomain(f)
end

@doc Markdown.doc"""
  isbijective(f::ModuleMap)
Test if `f` is bijective.
"""
function isbijective(f::ModuleMap)
  return isinjective(f) && issurjective(f)
end

@doc Markdown.doc"""
    iswelldefined(H::ModuleMap)
Test if `H` is well-defined.
"""
function iswelldefined(H::ModuleMap)
  if typeof(H) <: FreeModuleHom
    return true
  end
  M = domain(H)
  C = present(M).quo.matrix
  n,m = size(C)
  g = M[1]
  ImH = map(x -> H(x), gens(M))
  for i=1:n
    if !iszero(Base.sum([C[i,j]*ImH[j] for j=1:m]))
      return false
    end
  end
  return true
end

######################################
# Only for testing
######################################
using Random
RNG = Random.MersenneTwister(42)

@doc Markdown.doc"""
	array_to_matrix(A::Array,R::CRing = parent(A[1,1]))
Return `A` as an AbstractAlgebra Matrix
"""
function array_to_matrix(A::Array,R::CRing = parent(A[1,1]))
	Mat = AbstractAlgebra.MatrixSpace(R,size(A)...)
	return Mat(R.(A))
end

@doc Markdown.doc"""
	randpoly(R::Union{Nemo.PolyRing,Nemo.MPolyRing},coeffs=0:9,max_exp=4,max_terms=8)
> Return a random Polynomial from the Polynomial Ring $R$ with coefficients in $coeffs$
> with exponents between $0$ and $max_exp$ und between $0$ and $max_terms$ terms
"""
function randpoly(R::Ring,coeffs=0:9,max_exp=4,max_terms=8)
	n = nvars(R)
	K = base_ring(R)
	E = [[Random.rand(RNG,0:max_exp) for i=1:n] for j=1:max_terms]
	C = [K(Random.rand(RNG,coeffs)) for i=1:max_terms]
	M = MPolyBuildCtx(R)
	for i=1:max_terms
		push_term!(M,C[i],E[i])
	end
	return finish(M)
end

#=function matrix_to_map(A::AbstractAlgebra.MatElem, M::FreeMod, N::FreeMod)
  A = sparse_matrix(A)
  return Oscar.hom(M,N, [FreeModuleElem(A[i],N) for i=1:nrows(A)])
end=#

#############################################
# Test hom
#############################################
function to_julia_matrix(A::Union{MatElem})
  return eltype(A)[A[i, j] for i = 1:nrows(A), j = 1:ncols(A)]
end

function Base.reshape(M::MatElem, n, m)
  julia_matrix = to_julia_matrix(M)
  julia_matrix = reshape(julia_matrix, n, m)
  R = base_ring(M)
  mat_space = MatrixSpace(R, n, m)
  return mat_space(julia_matrix)
end

function hom2(f1::MatElem{T}, g1::MatElem{T}) where T
  R = base_ring(f1)
  s1, s0 = size(f1)
  t1, t0 = size(g1)

  g2 = matrix_kernel(g1)
  n = s1*t0
  m = s0*t0 + s1*t1
  delta::MatrixElem{T} = zero_matrix(R, m,n)
  #delta::Matrix{T} = zeros(R, n, m)
  for j=1:m
    #b_vector::Vector{T} = [i == j ? R(1) : R(0) for i=1:m]
    b_vector::MatrixElem{T} = zero_matrix(R, 1,m)
    b_vector[1,j] = R(1)
    #println(typeof(Core.Array(b_vector[1,1:s0*t0])))
    A = reshape(b_vector[1,1:s0*t0], s0, t0)
    #Mat = AbstractAlgebra.MatrixSpace(R, t0, s0)
    #A = Mat(A)
    B = reshape(b_vector[1,s0*t0+1:length(b_vector)], s1, t1)
    #Mat = AbstractAlgebra.MatrixSpace(R, t1, s1)
    #B = Mat(B)
    res = f1*A - B*g1
    res = reshape(res, 1, length(res))
    for i=1:length(res)
      delta[j,i] = res[1,i]
    end
  end

  #Mat = AbstractAlgebra.MatrixSpace(R, size(delta)...)
  #display(delta)
  gamma = matrix_kernel(delta)

  t2 = size(g2)[1]
  n = m
  m = s0*t1 + s1*t2
  #rho::Matrix{T} = zeros(R, n, m)
  rho::MatrixElem{T} = zero_matrix(R, m,n)
  for j=1:m
    #b_vector::Vector{T} = [R(0) for i=1:m]
    b_vector = zero_matrix(R, 1,m)
    b_vector[1,j] = R(1)
    C = reshape(b_vector[1,1:s0*t1], s0, t1)
    #Mat = AbstractAlgebra.MatrixSpace(R, t1, s0)
    #C = Mat(C)
    D = reshape(b_vector[1,s0*t1+1:length(b_vector)], s1, t2)
    #Mat = AbstractAlgebra.MatrixSpace(R, t2, s1)
    #D = Mat(D)
    res1 = C*g1
    res1 = reshape(res1, 1,length(res1))
    res2 = f1*C - D*g2
    res2 = reshape(res2, 1,length(res2))
    for i=1:length(res1)
        rho[j,i] = res1[1,i]
    end
    for i=1:length(res2)
        #rho[:,j] = vcat(vec(res1), vec(res2))
        rho[j,i+length(res1)] = res2[1,i]
    end
  end

  M = SubQuo(gamma, rho)

  function convert_to_matrix(v::SubQuoElem{T})
    if parent(v) !== M
      throw(DomainError("v does not represent a homomorphism"))
    end
    R = base_ring(M)
    #A = AbstractAlgebra.matrix(R,map(x -> convert_poly(R,x),Array(v.singular_v)))
    #A = map(x -> convert_poly(R,x),Array(v.singular_v))
    #A = AbstractAlgebra.matrix(R, t0, s0, A[1:s0*t0])'
    A = reshape(dense_row(v.repres.coords[R, 1:s0*t0], s0*t0), s0, t0)
    #A = matrix(R, t0, s0, dense_row(v.repres.coords[R, 1:s0*t0], s0*t0))'
    #A = v.v*v.parent_sq.generators  # ineffizienter
    #A = reshape(A[1,1:s0*t0], s0, t0)
    #N = cokernel(g1)
    #for i=1:s0ems) <: Tuple ? [i for i in elems] : [elems])

    #    row = lift(N,A[i,:])
    #    for j=1:t0
    #        A[i,j]=row[1,j]
    #    end
    #end
    return A
  end

  return M, convert_to_matrix
end

# lookup-tables only used in the old code
# lookup-tables to find the correct function, that converts subquotient elements to homomorphisms or homomorphisms to subquotient elements:
#global subquotient_elem_to_homomorphism_lookup_table = IdDict{Subquotient,Function}()
#global homomorphism_to_subquotient_elem_lookup_table = IdDict{Tuple{Subquotient,Subquotient},Function}()


# since hom yields possibly wrong results, this is an alternative implementation for comparison, 
# which is known to work correctly in various examples (by comparing with Macaulay2 and by testing 
# whether the homomorphism corresponding to elements of the subquotient are well-defined
# the function also supports simplification of the subquotient, while retaining the correspondence to 
# morphisms, which is essential for checking correctness and practical use of the output
@doc Markdown.doc"""
  hom2(M::Subquotient,N::Subquotient)
> Return a subquotient S such that $Hom(M,N) \cong S$
"""
function hom2(M::SubQuo{T},N::SubQuo{T},simplify=true) where T
  f1 = present(M).quo.matrix
  g1 = present(N).quo.matrix
  #f1 = presentation_matrix(M)
  #g1 = presentation_matrix(N)
  SQ, convert_to_matrix = hom2(f1,g1)
  if simplify
    SQ2, i, p = simplify_subquotient(SQ)
    to_homomorphism = function(elem::SubQuoElem{T})
      elem2 = i(elem)
      A = convert_to_matrix(elem2)
      return SubQuoHom(M,N,A)
      #return AbstractAlgebra.ModuleHomomorphism(M,N,A)
    end
    to_subquotient_elem = function(H::ModuleMap)
      m = length(H.matrix)
      v = reshape(H.matrix,1,m)
      #v = i(v)
      tmp_sq = Oscar.SubQuo(SQ.sub.matrix[:,1:m], SQ.quo.matrix[:,1:m])
      #tmp_sq = Subquotient(SQ.generators[:,1:m], SQ.relations[:,1:m])
      #coeffs = Nemo.lift(tmp_sq, v)
      v = FreeModuleElem(sparse_row(v), FreeMod(R, length(v)))
      coeffs = coordinates(v, tmp_sq)
      return p(SubQuoElem(coeffs, SQ))
      #return p(SubquotientElem(SQ, coeffs))
    end
    #subquotient_elem_to_homomorphism_lookup_table[SQ2] = elem -> to_homomorphism(elem)
    #homomorphism_to_subquotient_elem_lookup_table[(M,N)] = H -> to_subquotient_elem(H)

    to_hom_map = MapFromFunc(to_homomorphism, to_subquotient_elem, SQ2, Hecke.MapParent(M, N, "homomorphisms"))
    Hecke.set_special(SQ2, :hom => (M, N), :module_to_hom_map => to_hom_map)

    return SQ2
  else
    to_subquotient_elem = function(H::ModuleMap)
      m = length(H.matrix)
      v = reshape(H.matrix,1,m)
      #tmp_sq = Subquotient(SQ.generators[:,1:m], SQ.relations[:,1:m])
      tmp_sq = Oscar.SubQuo(SQ.sub.matrix[:,1:m], SQ.quo.matrix[:,1:m])
      v = FreeModuleElem(sparse_row(v), FreeMod(R, length(v)))
      coeffs = coordinates(v, tmp_sq)
      #coeffs = Nemo.lift(tmp_sq, v)
      return SubQuoElem(coeffs, SQ)
      #return SubquotientElem(SQ, coeffs)
    end
    to_homomorphism = function(elem::SubQuoElem{T})
      A = convert_to_matrix(elem)
      return SubQuoHom(M,N,A)
      #return AbstractAlgebra.ModuleHomomorphism(M,N,A)
    end
    #subquotient_elem_to_homomorphism_lookup_table[SQ] = to_homomorphism
    #homomorphism_to_subquotient_elem_lookup_table[(M,N)] = H -> to_subquotient_elem(H)

    to_hom_map = MapFromFunc(to_homomorphism, to_subquotient_elem, SQ, Hecke.MapParent(M, N, "homomorphisms"))
    Hecke.set_special(SQ, :hom => (M, N), :module_to_hom_map => to_hom_map)

    return SQ
  end
end
